<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Jaysonic Source: server/protocol/base.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.dark.css">

	<link type="text/css" rel="stylesheet" href="styles/site.simplex.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Jaysonic</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Jaysonic.html">Jaysonic</a></li><li><a href="Utils.html">Utils</a></li><li><a href="Utils.constants.html">Utils.constants</a></li><li><a href="Utils.format.html">Utils.format</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="HttpClientFactory.html">HttpClientFactory</a></li><li><a href="HttpClientProtocol.html">HttpClientProtocol</a></li><li><a href="HttpServerFactory.html">HttpServerFactory</a></li><li><a href="HttpServerProtocol.html">HttpServerProtocol</a></li><li><a href="JsonRpcClientFactory.html">JsonRpcClientFactory</a></li><li><a href="JsonRpcClientProtocol.html">JsonRpcClientProtocol</a></li><li><a href="JsonRpcServerFactory.html">JsonRpcServerFactory</a></li><li><a href="JsonRpcServerProtocol.html">JsonRpcServerProtocol</a></li><li><a href="MessageBuffer.html">MessageBuffer</a></li><li><a href="TcpClientFactory.html">TcpClientFactory</a></li><li><a href="TcpClientProtocol.html">TcpClientProtocol</a></li><li><a href="TcpServerFactory.html">TcpServerFactory</a></li><li><a href="TcpServerProtocol.html">TcpServerProtocol</a></li><li><a href="WsBrowserClientFactory.html">WsBrowserClientFactory</a></li><li><a href="WsBrowserClientProtocol.html">WsBrowserClientProtocol</a></li><li><a href="WsClientFactory.html">WsClientFactory</a></li><li><a href="WsClientProtocol.html">WsClientProtocol</a></li><li><a href="WsServerFactory.html">WsServerFactory</a></li><li><a href="WsServerProtocol.html">WsServerProtocol</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: server/protocol/base.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">const MessageBuffer = require("../../util/buffer");
const { formatResponse, formatError } = require("../../util/format");
const { ERR_CODES, ERR_MSGS } = require("../../util/constants");

/**
 * Creates an instance of JsonRpcServerProtocol. This is the
 * base protocol from which all others inherit.
 *
 */
class JsonRpcServerProtocol {
  /**
   * @param {class} factory Instance of [JsonRpcServerFactory]{@link JsonRpcServerFactory}
   * @param {class} client Instance of `net.Socket`
   * @param {string|number} version JSON-RPC version to use
   * @param {string} delimiter Delimiter to use for `messageBuffer`
   * @property {class} messageBuffer Instance of [MessageBuffer]{@link MessageBuffer}
   * @property {string} event="data" The event name to listen for incoming data
   */
  constructor(factory, client, version, delimiter) {
    this.client = client;
    this.factory = factory;
    this.delimiter = delimiter;
    this.version = version;
    this.messageBuffer = new MessageBuffer(delimiter);
    this.event = "data";
  }

  /**
   * Registers the `event` listener when client connects.
   *
   * Pushes received data into `messageBuffer` and calls
   * [_waitForData]{@link JsonRpcServerProtocol#_waitForData}.
   *
   * Registers `end` event to emit a `clientDisconnected` event
   * on the factory
   *
   */
  clientConnected() {
    this.client.on(this.event, (data) => {
      this.messageBuffer.push(data);
      this._waitForData();
    });
    this.client.on("end", () => {
      this.factory.emit("clientDisconnected", this.client);
    });
  }

  /**
   * Accumulate data while [MessageBuffer.isFinished]{@link MessageBuffer#isFinished} is returning false.
   *
   * If the buffer returns a message it will be passed to [validateRequest]{@link JsonRpcServerProtocol#validateRequest}.
   * If [validateRequest]{@link JsonRpcServerProtocol#validateRequest} returns a parsed result, then the result
   * is passed to [_maybeHandleRequest]{@link JsonRpcServerProtocol#_maybeHandleRequest}.
   * If [_maybeHandleRequest]{@link JsonRpcServerProtocol#_maybeHandleRequest} returns true, then
   * [gotRequest]{@link JsonRpcServerProtocol#gotRequest} is called.&lt;br/>&lt;br/>
   *
   * If any of the above throws an error, [gotError]{@link JsonRpcServerProtocol#gotError} is called.
   *
   * @private
   *
   */
  _waitForData() {
    while (!this.messageBuffer.isFinished()) {
      const chunk = this.messageBuffer.handleData();
      try {
        const result = this.validateRequest(chunk);
        const isMessage = this._maybeHandleRequest(result);
        if (isMessage) {
          this.gotRequest(result);
        }
      } catch (e) {
        this.gotError(e);
      }
    }
  }

  /**
   * Validate the incoming data returned from `messageBuffer`
   *
   * @param {string} chunk
   * @return {JSON}
   * @throws Will throw an error with a JSON-RPC error object if chunk cannot be parsed
   */
  validateRequest(chunk) {
    try {
      return JSON.parse(chunk);
    } catch (e) {
      throw new Error(
        formatError({
          jsonrpc: this.version,
          id: null,
          code: ERR_CODES.parseError,
          message: ERR_MSGS.parseError,
          delimiter: this.delimiter
        })
      );
    }
  }

  /**
   * Determines the type of request being made (batch, notification, request) and
   * calls the corresponding function.
   *
   * @param {JSON} result Valid JSON-RPC request object
   * @private
   */
  _maybeHandleRequest(result) {
    if (Array.isArray(result)) {
      if (result.length === 0) {
        return this.writeToClient(
          formatError({
            code: ERR_CODES.invalidRequest,
            message: ERR_MSGS.invalidRequest,
            delimiter: this.delimiter,
            jsonrpc: this.version,
            id: null
          })
        );
      }
      // possible batch request
      this.gotBatchRequest(result).then((res) => {
        this.writeToClient(JSON.stringify(res) + this.delimiter);
      });
    } else if (result === Object(result) &amp;&amp; !("id" in result)) {
      // no id, so assume notification
      this.gotNotification(result);
    } else {
      this.validateMessage(result);
      return true;
    }
  }

  /**
   * Validates if there are any issues with the incoming request&lt;br/>
   *
   *
   * @param {JSON} message Valid JSON-RPC request object
   * @throws Will throw an error for any of the below reasons
   *
   * Reason|Type
   * ---|---
   * message is not an object| Invalid Request
   * the server does not have the required method| Method Not Found
   * the params are not an array or object| Invalid Params
   * the "jsonrpc" property was passed for a v1 server| Invalid Request
   */
  validateMessage(message) {
    if (!(message === Object(message))) {
      this._raiseError(ERR_MSGS.invalidRequest, ERR_CODES.invalidRequest, null);
    } else if (!(typeof message.method === "string")) {
      this._raiseError(
        ERR_MSGS.invalidRequest,
        ERR_CODES.invalidRequest,
        message.id
      );
    } else if (!(message.method in this.factory.methods)) {
      this._raiseError(
        ERR_MSGS.methodNotFound,
        ERR_CODES.methodNotFound,
        message.id
      );
    } else if (
      message.params &amp;&amp;
      !Array.isArray(message.params) &amp;&amp;
      !(message.params === Object(message.params))
    ) {
      this._raiseError(
        ERR_MSGS.invalidParams,
        ERR_CODES.invalidParams,
        message.id
      );
    } else if (message.jsonrpc &amp;&amp; this.version !== "2.0") {
      this._raiseError(
        ERR_MSGS.invalidRequest,
        ERR_CODES.invalidRequest,
        message.id
      );
    }
  }

  /**
   * Send message to the client
   *
   * @param {string} message Stringified JSON-RPC message object
   */
  writeToClient(message) {
    this.client.write(message);
  }

  /**
   * Calls `emit` on factory with the event name being `message.method` and
   * the date being `message`.
   *
   * @param {string} message Stringified JSON-RPC message object
   */
  gotNotification(message) {
    this.factory.emit(message.method, message);
  }

  /**
   * Attempts to get the result for the request object. Will
   * send result to client if successful and will send an error
   * otherwise.
   *
   * @param {JSON} message JSON-RPC message object
   * @returns {Promise}
   */
  gotRequest(message) {
    return this.getResult(message)
      .then((result) => {
        this.writeToClient(result);
      })
      .catch((error) => {
        this.gotError(Error(error));
      });
  }

  /**
   * Attempts to get the result for all requests in the batch.
   * Will send result to client if successful and error otherwise.
   *
   * @param {JSON[]} requests Valid JSON-RPC batch request
   * @returns {Promise[]}
   */
  gotBatchRequest(requests) {
    const batchResponses = requests
      .map((request) => {
        try {
          this._maybeHandleRequest(request);
          return this.getResult(request)
            .then((result) => JSON.parse(result))
            .catch((error) => JSON.parse(error));
        } catch (e) {
          // basically reject the whole batch if any one thing fails
          return JSON.parse(e.message);
        }
      })
      .filter((el) => el != null);
    return Promise.all(batchResponses);
  }

  /**
   * Get the result for the request. Calls the function associated
   * with the method and returns the result.
   *
   * @param {JSON} message Valid JSON-RPC message object
   * @returns {Promise}
   */
  getResult(message) {
    // function needs to be async since the method can be a promise
    return new Promise((resolve, reject) => {
      const { params } = message;
      const response = {
        jsonrpc: message.jsonrpc,
        id: message.id,
        delimiter: this.delimiter
      };
      const error = {
        jsonrpc: message.jsonrpc,
        id: message.id,
        delimiter: this.delimiter
      };
      try {
        const result = params
          ? this.factory.methods[message.method](params)
          : this.factory.methods[message.method]();
        if (result instanceof Promise || typeof result.then === "function") {
          Promise.all([result])
            .then((results) => {
              response.result = results || 0;
              resolve(formatResponse(response));
            })
            .catch((resError) => {
              error.code = ERR_CODES.internal;
              error.message = `${JSON.stringify(resError.message || resError)}`;
              reject(formatError(error));
            });
        } else {
          response.result = result || 0;
          resolve(formatResponse(response));
        }
      } catch (e) {
        if (e instanceof TypeError) {
          error.code = ERR_CODES.invalidParams;
          error.message = ERR_MSGS.invalidParams;
          // error.data = e.message;
        } else {
          error.code = ERR_CODES.unknown;
          error.message = ERR_MSGS.unknown;
          // error.data = e.message;
        }
        reject(formatError(error));
      }
    });
  }

  /**
   *
   * @param {string} message Error message
   * @param {number} code Error code
   * @param {string|number} id Error message ID
   * @throws Throws a JSON-RPC error object
   * @private
   */
  _raiseError(message, code, id) {
    const error = formatError({
      jsonrpc: this.version,
      delimiter: this.delimiter,
      id,
      code,
      message
    });
    throw new Error(error);
  }

  /**
   * Writes error to the client. Will send a JSON-RPC error object if the
   * passed error cannot be parsed.
   *
   * @param {string} error Stringified error object
   */
  gotError(error) {
    let err;
    try {
      err = JSON.stringify(JSON.parse(error.message));
    } catch (e) {
      err = formatError({
        jsonrpc: this.version,
        delimiter: this.delimiter,
        id: null,
        code: ERR_CODES.unknown,
        message: JSON.stringify(error, Object.getOwnPropertyNames(error))
      });
    }
    this.writeToClient(err + this.delimiter);
  }
}

module.exports = JsonRpcServerProtocol;
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a>
	
		on 2020-10-12T21:58:27-04:00
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
