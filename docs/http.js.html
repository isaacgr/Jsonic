<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: http.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: http.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const http = require("http");
const JsonRpcClientProtocol = require("./base");

/**
 * Creates an instance of HttpClientProtocol, which has some tweaks from the base class
 * required to work with the `node.http` package
 *
 * Inherits from JsonRpcClientProtocol
 */
class HttpClientProtocol extends JsonRpcClientProtocol {
  /**
   * HttpClientProtocol contructor
   *
   * @param {class} factory Instance of factory class
   * @param {string|number} version JSON-RPC version to use (1 or '2.0')
   * @param {string} delimiter Delimiter to use for message buffer
   */
  constructor(factory, version, delimiter) {
    super(factory, version, delimiter);
    this.headers = this.factory.headers;
    this.encoding = this.factory.encoding;
  }

  /**
   * Send a message to the server. Sets the request headers given in `factory.headers`
   *
   * Calls `listen` to start listening for recieved data from server.
   *
   * Ends connection when all data received from the server.
   *
   * Emits a `serverDisconnected` event when connection is closed.
   *
   * Throws an error if there was an `error` event received when sending the request
   *
   * @param {string} request Stringified JSON-RPC message object
   * @param {function=} cb Callback function to be called when message has been sent
   */
  write(request, cb) {
    const options = {
      ...this.factory.options,
      ...this.headers
    };
    this.headers["Content-Length"] = Buffer.byteLength(request, this.encoding);
    this.connector = http.request(options, (response) => {
      if (cb) {
        response.on("end", cb);
      }
      this.listener = response;
      this.listen();
    });
    this.connector.write(request, this.encoding);
    this.connector.end();
    this.connector.on("close", () => {
      this.factory.emit("serverDisconnected");
    });
    this.connector.on("error", (error) => {
      throw error;
    });
  }

  /**
   * Send a notification to the server.
   *
   * Promise will resolve if the request was sucessfully sent, and reject if
   * there was an error sending the request. For the HttpClientProtocol, the resolved promise
   * will return the http response object with a 204 response code per the spec.
   *
   * @param {string} method Name of the method to use in the notification
   * @param {Array|JSON} params Params to send
   * @return Promise
   * @example
   *    client.notify("hello", ["world"])
   */
  notify(method, params) {
    return new Promise((resolve, reject) => {
      const request = this.message(method, params, false);
      try {
        this.write(request, () => {
          if (this.listener.statusCode === 204) {
            resolve(this.listener);
          } else {
            reject(new Error("no response receieved for notification"));
          }
        });
      } catch (e) {
        // this.connector is probably undefined
        reject(e);
      }
    });
  }

  /**@inheritdoc */
  getResponse(id) {
    return {
      body: this.responseQueue[id],
      ...this.writer
    };
  }

  /**@inheritdoc */
  getBatchResponse(batch) {
    return {
      body: batch,
      ...this.connector
    };
  }

  /**@inheritdoc */
  rejectPendingCalls(error) {
    const err = {
      body: error,
      ...this.connector
    };
    try {
      this.pendingCalls[err.body.id].reject(err);
      this.factory.cleanUp(err.body.id);
    } catch (e) {
      if (e instanceof TypeError) {
        // probably a parse error, which might not have an id
        console.error(
          `Message has no outstanding calls: ${JSON.stringify(err.body)}`
        );
      }
    }
  }
}

module.exports = HttpClientProtocol;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="HttpClientProtocol.html">HttpClientProtocol</a></li><li><a href="JsonRpcClientProtocol.html">JsonRpcClientProtocol</a></li><li><a href="TcpClientProtocol.html">TcpClientProtocol</a></li><li><a href="WsBrowserClientProtocol.html">WsBrowserClientProtocol</a></li><li><a href="WsClientProtocol.html">WsClientProtocol</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Sun Oct 11 2020 18:27:05 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
