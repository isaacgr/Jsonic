<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"client_http.js.html":{"id":"client_http.js.html","title":"Source: client/http.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: client/http.js const JsonRpcClientFactory = require(\".\"); const HttpClientProtocol = require(\"./protocol/http\"); /** * Creates instance of HttpClientFactory * * @extends JsonRpcClientFactory */ class HttpClientFactory extends JsonRpcClientFactory { /** * Additional parameters ontop of those inherited from [JsonRpcClientFactory]{@link JsonRpcClientFactory} * @param {Object} options Connection options for the factory class * @param {string} [options.encoding=\"utf-8\"] Encoding to be used for the request * @param {string} [options.method=\"POST\"] Type of request to make * @param {object} [options.headers={\"Content-Type\": \"application/json\", Accept: \"application/json\"}] Request headers * @param {string} [options.path=\"/\"] URL path to make request to * @property {object} headers Same as `options.headers` * @property {string} encoding Same as `options.encoding` */ constructor(options) { super(options); if (!(this instanceof HttpClientFactory)) { return new HttpClientFactory(options); } // the content length will be calculated on a per request basis // according to the node http docs: // the encoding argument is optional and only applies when chunk is a string. // Defaults to 'utf8'. const defaults = { encoding: \"utf-8\", method: \"POST\", headers: { \"Content-Type\": \"application/json\", Accept: \"application/json\" }, path: \"/\" }; this.options = { ...defaults, ...(this.options || {}) }; this.headers = this.options.headers; this.encoding = this.options.encoding; this.pcolInstance = new HttpClientProtocol( this, this.options.version, this.options.delimiter ); } } module.exports = HttpClientFactory; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"client_index.js.html":{"id":"client_index.js.html","title":"Source: client/index.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: client/index.js const EventEmitter = require(\"events\"); /** * Creates an instance of JsonRpcClientFactory. This is the base factory which * all other factories inherit from. * * @extends EventEmitter * @requires events */ class JsonRpcClientFactory extends EventEmitter { /** * @inheritdoc * @param {Object} options Connection options for the factory class * @param {string} [options.host=\"127.0.0.1\"] IP of server to connect to * @param {number} [options.port=8100] Port of server to connect to * @param {number} [options.version=2] JSON-RPC version to use (1|2) * @param {string} [options.delimiter=\"\\n\"] Delimiter to use for requests * @param {number} [options.timeout=30] Timeout for request response * @param {number} [options.connectionTimeout=5000] Timeout for connection to server * @param {number} [options.retries=2] Number of connection retry attempts * @property {class} pcolInstance The [JsonRpcClientProtocol]{@link JsonRpcClientProtocol} instance * @property {object} timeouts Key value pairs of request IDs to `setTimeout` instance * @property {number} requestTimeout Same as `options.timeout` * @property {number} remainingRetries Same as `options.retries` * @property {number} connectionTimeout Same as `options.connectionTimeout` * @property {object} server Object of host and port `{host: options.host, port: options.port}` */ constructor(options) { super(); if (!(this instanceof JsonRpcClientFactory)) { return new JsonRpcClientFactory(options); } const defaults = { host: \"127.0.0.1\", port: \"8100\", version: \"2.0\", delimiter: \"\\n\", timeout: 30, connectionTimeout: 5000, retries: 2 }; this.options = { ...defaults, ...(options || {}) }; this.pcolInstance = undefined; this.timeouts = {}; this.requestTimeout = this.options.timeout * 1000; this.remainingRetries = this.options.retries; this.connectionTimeout = this.options.connectionTimeout; this.server = { host: this.options.host, port: this.options.port }; } /** * Calls `connect()` on protocol instance * * @abstract */ connect() { throw new Error(\"function must be overwritten in subclass\"); } /** * Calls `end()` on protocol instance * * @abstract */ end() { throw new Error(\"function must be overwritten in subclass\"); } /** * Subscribe the function to the given event name * * @param {string} method Method to subscribe to * @param {function} cb Name of callback function to invoke on event * @abstract */ subscribe() { throw new Error(\"function must be overwritten in subsclass\"); } /** * Unsubscribe the function from the given event name * * @param {string} method Method to unsubscribe from * @param {function} cb Name of function to remove * @abstract */ unsubscribe() { throw new Error(\"function must be overwritten in subsclass\"); } /** * Unsubscribe all functions from given event name * * @param {string} method Method to unsubscribe all listeners from * @abstract */ unsubscribeAll() { throw new Error(\"function must be overwritten in subsclass\"); } /** * Calls `request()` method on protocol instance */ request() { return this.pcolInstance.request(); } /** * Calls `batch()` method on protocol instance * * @param {JSON[]} requests Valid JSON-RPC batch request array */ batch(requests) { return this.pcolInstance.batch(requests); } /** * Emits a `serverDisconnected` event, passing the callback function * * @param {function} cb */ serverDisconnected(cb) { this.on(\"serverDisconnected\", cb); } /** * Clears pending timeouts kept in `timeouts` for the provided request IDs. * * @param {string[]|number[]} ids Array of request IDs */ cleanUp(ids) { clearTimeout(this.timeouts[ids]); delete this.timeouts[ids]; } } module.exports = JsonRpcClientFactory; /** * TCP client constructor * @type TcpClientFactory * @static */ JsonRpcClientFactory.tcp = require(\"./tcp\"); /** * HTTP client constructor * @type HttpClientFactory * @static */ JsonRpcClientFactory.http = require(\"./http\"); /** * WebSocket client constructor * @type WsClientFactory * @static */ JsonRpcClientFactory.ws = require(\"./ws\"); × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"client_protocol_http.js.html":{"id":"client_protocol_http.js.html","title":"Source: client/protocol/http.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: client/protocol/http.js const http = require(\"http\"); const JsonRpcClientProtocol = require(\"./base\"); /** * Creates an instance of HttpClientProtocol, which has some tweaks from the base class * required to work with the `node.http` package * * @extends JsonRpcClientProtocol * @requires http */ class HttpClientProtocol extends JsonRpcClientProtocol { /** @inheritdoc */ /** * @property {object} headers HTTP headers passed to the factory instance * * @property {string} encoding Encoding type passed to the factory instance */ constructor(factory, version, delimiter) { super(factory, version, delimiter); this.headers = this.factory.headers; this.encoding = this.factory.encoding; } /** * Send a message to the server. Sets the request headers passed into `headers` * * Calls [listen]{@link JsonRpcClientProtocol#listen} to start listening for recieved data from server. * * Ends connection when all data received from the server. * * Emits a `serverDisconnected` event when connection is closed. * * Throws an error if there was an `error` event received when sending the request * * @param {string} request Stringified JSON-RPC message object * @param {function=} cb Callback function to be called when message has been sent */ write(request, cb) { const options = { ...this.factory.options, ...this.headers }; this.headers[\"Content-Length\"] = Buffer.byteLength(request, this.encoding); this.connector = http.request(options, (response) =&gt; { if (cb) { response.on(\"end\", cb); } this.listener = response; this.listen(); }); this.connector.write(request, this.encoding); this.connector.end(); this.connector.on(\"close\", () =&gt; { this.factory.emit(\"serverDisconnected\"); }); this.connector.on(\"error\", (error) =&gt; { throw error; }); } /** * Send a notification to the server. * * Promise will resolve if the request was sucessfully sent, and reject if * there was an error sending the request. For the [HttpClientProtocol]{@link HttpClientProtocol}, the resolved promise * will return the http response object with a `204` response code per the spec. * * @param {string} method Name of the method to use in the notification * @param {Array|JSON} params Params to send * @return Promise * @example * client.notify(\"hello\", [\"world\"]) */ notify(method, params) { return new Promise((resolve, reject) =&gt; { const request = this.message(method, params, false); try { this.write(request, () =&gt; { if (this.listener.statusCode === 204) { resolve(this.listener); } else { reject(new Error(\"no response receieved for notification\")); } }); } catch (e) { // this.connector is probably undefined reject(e); } }); } /** @inheritdoc */ getResponse(id) { return { body: this.responseQueue[id], ...this.writer }; } /** @inheritdoc */ getBatchResponse(batch) { return { body: batch, ...this.connector }; } /** @inheritdoc */ rejectPendingCalls(error) { const err = { body: error, ...this.connector }; try { this.pendingCalls[err.body.id].reject(err); this.factory.cleanUp(err.body.id); } catch (e) { if (e instanceof TypeError) { // probably a parse error, which might not have an id console.error( `Message has no outstanding calls: ${JSON.stringify(err.body)}` ); } } } } module.exports = HttpClientProtocol; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"client_protocol_base.js.html":{"id":"client_protocol_base.js.html","title":"Source: client/protocol/base.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: client/protocol/base.js const { formatRequest, formatError } = require(\"../../util/format\"); const { ERR_CODES, ERR_MSGS } = require(\"../../util/constants\"); const MessageBuffer = require(\"../../util/buffer\"); /** * Creates an instance of the base client protocol class. * This is the class that all other client protocols inherit from. */ class JsonRpcClientProtocol { /** * JsonRpcClientProtocol contructor * @param {class} factory Instance of [JsonRpcClientFactory]{@link JsonRpcClientFactory} * @param {string|number} version JSON-RPC version to use (1 or '2.0') * @param {string} delimiter Delimiter to use for message buffer * @property {class} factory Instance of [JsonRpcClientFactory]{@link JsonRpcClientFactory} * @property {class} connector The socket instance for the client * @property {string|number} version JSON-RPC version to use (1 or '2.0') * @property {string} delimiter Delimiter to use for message buffer * @property {number} message_id Current message ID * @property {number} serving_message_id Current message ID. Used for external functions to hook into * @property {Object} pendingCalls Key value pairs for pending message IDs to promise resolve/reject objects * @property {Object.&lt;string|number, JSON&gt;} responseQueue Key value pairs for outstanding message IDs to response object * @property {Object} server Server host and port object {host: \"x.x.x.x\", port: xxxx} * @property {class} messageBuffer Instance of [MessageBuffer]{@link MessageBuffer} * */ constructor(factory, version, delimiter) { if (!(this instanceof JsonRpcClientProtocol)) { return new JsonRpcClientProtocol(factory, version, delimiter); } this.factory = factory; this.connector = undefined; this.listener = undefined; this.delimiter = delimiter; this.version = version; this.message_id = 1; this.serving_message_id = 1; this.pendingCalls = {}; this.responseQueue = {}; this.server = this.factory.server; this.messageBuffer = new MessageBuffer(this.delimiter); } /** * Set the `connector` attribute for the protocol instance. * The connector is essentially the socket instance for the client. * * @abstract * */ setConnector() { throw Error(\"function must be overwritten in subclass\"); } /** * Make the connection to the server. * * Calls [setConnector]{@link JsonRpcClientProtocol#setConnector} to establish the node client connection. * * Calls [listen]{@link JsonRpcClientProtocol#listen} if connection was successful, and will resolve the promise. * * Will retry connection on the `connectionTimeout` interval. * Number of connection retries is based on `remainingRetries` * * Will reject the promise if connect or re-connect attempts fail. * * @returns Promise * * */ connect() { return new Promise((resolve, reject) =&gt; { const retryConnection = () =&gt; { this.setConnector(); this.connector.connect(this.server); this.connector.setEncoding(\"utf8\"); this.connector.on(\"connect\", () =&gt; { this.listener = this.connector; this.listen(); resolve(this.server); }); this.connector.on(\"error\", (error) =&gt; { if (error.code === \"ECONNREFUSED\" &amp;&amp; this.factory.remainingRetries) { this.factory.remainingRetries -= 1; console.error( `Unable to connect. Retrying. ${this.factory.remainingRetries} attempts left.` ); setTimeout(() =&gt; { retryConnection(); }, this.factory.connectionTimeout); } else { this.factory.pcolInstance = undefined; reject(error); } }); }; return retryConnection(); }); } /** * Ends connection to the server. * * Sets `JsonRpcClientFactory.pcolInstance` to `undefined` * * @param {function} cb Called when connection is sucessfully closed */ end(cb) { this.factory.pcolInstance = undefined; this.connector.end(cb); } /** * Setup \"data\" event to listen for data coming into the client. * * Pushes received data into `messageBuffer` and calls * [_waitForData]{@link JsonRpcClientProtocol#_waitForData} */ listen() { this.listener.on(\"data\", (data) =&gt; { this.messageBuffer.push(data); this._waitForData(); }); } /** * Accumulate data while [MessageBuffer.isFinished]{@link MessageBuffer#isFinished} is returning false. * * If the buffer returns a message it will be passed to [verifyData]{@link JsonRpcClientProtocol#verifyData} * * @private * */ _waitForData() { while (!this.messageBuffer.isFinished()) { const message = this.messageBuffer.handleData(); try { this.verifyData(message); } catch (e) { this.gotError(e); } } } /** * Verify the incoming data returned from `messageBuffer` * * Throw an error if its not a valid JSON-RPC object. * * Call [gotNotification]{@link JsonRpcClientProtocol#gotNotification} if the message a notification. * * Call [gotBatch]{@link JsonRpcClientProtocol#gotBatch} if the message is a batch request. * * @param {string} chunk */ verifyData(chunk) { try { // will throw an error if not valid json const message = JSON.parse(chunk); if (Array.isArray(message)) { this.gotBatch(message); } else if (!(message === Object(message))) { // error out if it cant be parsed throw SyntaxError(); } else if (!(\"id\" in message)) { // no id, so assume notification this.gotNotification(message); } else if (message.error) { // got an error back so reject the message const { id } = message; const { code } = message.error; const errorMessage = message.error.message; this._raiseError(errorMessage, code, id); } else if (!message.method) { // no method, so assume response this.gotResponse(message); } else { const code = ERR_CODES.unknown; const errorMessage = ERR_MSGS.unknown; this._raiseError(errorMessage, code, null); } } catch (e) { if (e instanceof SyntaxError) { const code = ERR_CODES.parseError; const errorMessage = `Unable to parse message: '${chunk}'`; this._raiseError(errorMessage, code, null); } else { throw e; } } } /** * Called when the received `message` is a notification. * Emits an event using `message.method` as the name. * The data passed to the event gotr is the `message`. * * @param {JSON} message A valid JSON-RPC message object */ gotNotification(message) { this.factory.emit(message.method, message); } /** * Called when the received message is a batch * * @param {JSON[]} message A valid JSON-RPC batch message */ gotBatch(message) { // possible batch request message.forEach((res) =&gt; { if (res &amp;&amp; res.method &amp;&amp; !res.id) { this.factory.emit(res.method, res); } }); this.gotBatchResponse(message); } /** * Called when the received message is a response object from the server * * @param {JSON} message A valid JSON-RPC message object */ gotResponse(message) { this.serving_message_id = message.id; this.responseQueue[message.id] = message; try { const response = this.getResponse(message.id); this.pendingCalls[message.id].resolve(response); delete this.responseQueue[message.id]; this.factory.cleanUp(message.id); } catch (e) { if (e instanceof TypeError) { // probably a parse error, which might not have an id console.error( `Message has no outstanding calls: ${JSON.stringify(e.message)}` ); } } } /** * Get the outstanding request object for the given ID * * @param {string|number} id ID of outstanding request */ getResponse(id) { return this.responseQueue[id]; } /** * Send a message to the server * * @param {string} request Stringified JSON-RPC message object * @param {function=} cb Callback function to be called when message has been sent */ write(request, cb) { this.connector.write(request, cb); } /** * Generate a stringified JSON-RPC message object * * @param {string} method Name of the method to use in the request * @param {Array|JSON} params Params to send * @param {boolean=} id If true it will use instances `message_id` for the request id, if false will generate a notification request * @example * client.message(\"hello\", [\"world\"]) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"], \"id\": 1} * client.message(\"hello\", [\"world\"], false) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"]} */ message(method, params, id = true) { const request = formatRequest({ method, params, id: id ? this.message_id : undefined, version: this.version, delimiter: this.delimiter }); if (id) { this.message_id += 1; } return request; } /** * Send a notification to the server. * * Promise will resolve if the request was sucessfully sent, and reject if * there was an error sending the request. * * @param {string} method Name of the method to use in the notification * @param {Array|JSON} params Params to send * @return Promise * @example * client.notify(\"hello\", [\"world\"]) */ notify(method, params) { return new Promise((resolve, reject) =&gt; { const request = this.message(method, params, false); try { this.write(request, () =&gt; { resolve(request); }); } catch (e) { // this.connector is probably undefined reject(e); } }); } /** * Send a request to the server * * Promise will resolve when a response has been received for the request. * * Promise will reject if the server responds with an error object, or if * the response is not received within the set `requestTimeout` * * @param {string} method Name of the method to use in the request * @param {Array|JSON} params Params to send * @returns Promise * @example * client.send(\"hello\", {\"foo\": \"bar\"}) */ send(method, params) { return new Promise((resolve, reject) =&gt; { const request = this.message(method, params); this.pendingCalls[JSON.parse(request).id] = { resolve, reject }; try { this.write(request); } catch (e) { // this.connector is probably undefined reject(e); } this._timeoutPendingCalls(JSON.parse(request).id); }); } /** * Method used to call [message]{@link JsonRpcClientProtocol#message}, [notify]{@link JsonRpcClientProtocol#notify} and [send]{@link JsonRpcClientProtocol#send} * @returns Object * @example * client.request().send(\"hello\", [\"world\"]) * client.request().notify(\"foo\") * client.request().message(\"foo\", [\"bar\"]) * */ request() { const self = this; return { message: this.message.bind(self), send: this.send.bind(self), notify: this.notify.bind(self) }; } /** * Used to send a batch request to the server. * * Recommend using [message]{@link JsonRpcClientProtocol#message} to construct objects. * * Will use the IDs for the requests in the batch in an array as the keys for `pendingCalls`. * How a client should associate batch responses is not in the spec, so this is the solution. * * @param {Array} requests An array of valid JSON-RPC message objects * @returns Promise * @example * client.batch([client.message(\"foo\", [\"bar\"]), client.message(\"hello\", [], false)]) */ batch(requests) { return new Promise((resolve, reject) =&gt; { const batchIds = []; const batchRequests = []; for (const request of requests) { const json = JSON.parse(request); batchRequests.push(json); if (json.id) { batchIds.push(json.id); } } this.pendingCalls[String(batchIds)] = { resolve, reject }; const request = JSON.stringify(batchRequests); try { this.write(request + this.delimiter); } catch (e) { // this.connector is probably undefined reject(e.message); } this._timeoutPendingCalls(String(batchIds)); }); } /** * Associate the ids in the batch message to their corresponding `pendingCalls`. * * Will call [_resolveOrRejectBatch]{@link JsonRpcClientProtocol#_resolveOrRejectBatch} when object is determined * @param {Array} batch Array of valid JSON-RPC message objects */ gotBatchResponse(batch) { const batchResponseIds = []; batch.forEach((message) =&gt; { if (\"id\" in message) { batchResponseIds.push(message.id); } }); if (batchResponseIds.length === 0) { // dont do anything here since its basically an invalid response return; } // find the resolve and reject objects that match the batch request ids for (const ids of Object.keys(this.pendingCalls)) { const arrays = [JSON.parse(`[${ids}]`), batchResponseIds]; const difference = arrays.reduce((a, b) =&gt; a.filter((c) =&gt; !b.includes(c)) ); if (difference.length === 0) { this.factory.cleanUp(ids); this._resolveOrRejectBatch(batch, batchResponseIds); } } } /** * Returns the batch response. * * Overwrite if class needs to reformat in anyway (i.e. in [HttpClientProtocol]{@link HttpClientProtocol}) * @param {Array} batch Array of valid JSON-RPC message objects */ getBatchResponse(batch) { return batch; } /** * Will reject the request associated with the given ID with a JSON-RPC formated error object. * * Removes the id from `pendingCalls` and delete outstanding timeouts. * @param {string|number} id ID of the request to timeout * @private */ _timeoutPendingCalls(id) { this.factory.timeouts[id] = setTimeout(() =&gt; { this.factory.cleanUp(id); try { const error = JSON.parse( formatError({ jsonrpc: this.version, delimiter: this.delimiter, id: typeof id === \"string\" ? null : id, code: ERR_CODES.timeout, message: ERR_MSGS.timeout }) ); this.pendingCalls[id].reject(error); delete this.pendingCalls[id]; } catch (e) { if (e instanceof TypeError) { console.error( `Message has no outstanding calls: ${JSON.stringify(e)}` ); } } }, this.factory.requestTimeout); } /** * Resolve or reject the given batch request based on the given batch IDs. * * @param {Array} batch Valid JSON-RPC batch request * @param {string} batchIds Stringified list of batch IDs associated with the given batch * @private */ _resolveOrRejectBatch(batch, batchIds) { const batchResponse = this.getBatchResponse(batch); try { const invalidBatches = []; batch.forEach((message) =&gt; { if (message.error) { // reject the whole message if there are any errors this.pendingCalls[batchIds].reject(batchResponse); invalidBatches.push(batchIds); } }); if (invalidBatches.length !== 0) { invalidBatches.forEach((id) =&gt; { delete this.pendingCalls[id]; }); } else { this.pendingCalls[batchIds].resolve(batchResponse); delete this.pendingCalls[batchIds]; } } catch (e) { if (e instanceof TypeError) { // no outstanding calls console.log( `Batch response has no outstanding calls. Response IDs [${batchIds}]` ); } } } /** * Throws an Error whos message is a JSON-RPC error object * * @param {string} message Error message * @param {number} code Error code * @param {string|number=} id ID for error message object * @throws Error * @private */ _raiseError(message, code, id) { const error = formatError({ jsonrpc: this.version, delimiter: this.delimiter, id, code, message }); throw new Error(error); } /** * Calls [rejectPendingCalls]{@link JsonRpcClientProtocol#rejectPendingCalls} with error object. * If the object cannot be parsed, then an unkown error code is sent with the error message * * @param {string} error Stringified JSON-RPC error object */ gotError(error) { let err; try { err = JSON.parse(error.message); } catch (e) { err = JSON.parse( formatError({ jsonrpc: this.version, delimiter: this.delimiter, id: null, code: ERR_CODES.unknown, message: JSON.stringify(error, Object.getOwnPropertyNames(error)) }) ); } this.rejectPendingCalls(err); } /** * Reject the pending call for the given ID in the error object. * If the error object has a null id, then log the message to the console. * * @param {string} error Stringified JSON-RPC error object * */ rejectPendingCalls(error) { try { this.pendingCalls[error.id].reject(error); this.factory.cleanUp(error.id); } catch (e) { if (e instanceof TypeError) { // probably a parse error, which might not have an id console.error( `Message has no outstanding calls: ${JSON.stringify(error)}` ); } } } } module.exports = JsonRpcClientProtocol; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"server_http.js.html":{"id":"server_http.js.html","title":"Source: server/http.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: server/http.js const http = require(\"http\"); const JsonRpcServerFactory = require(\".\"); const HttpServerProtocol = require(\"./protocol/http\"); const { errorToStatus } = require(\"../util/constants\"); /** * Creates instance of HttpServerFactory * @extends JsonRpcServerFactory */ class HttpServerFactory extends JsonRpcServerFactory { /** @inheritdoc */ setServer() { this.server = new http.Server(); } /** @inheritdoc */ buildProtocol() { this.server.on(\"connection\", (client) =&gt; { this.connectedClients.push(client); this.emit(\"clientConnected\", client); client.on(\"close\", () =&gt; { this.emit(\"clientDisconnected\"); }); // client.on(\"end\", () =&gt; { // this.emit(\"clientDisconnected\"); // }); }); this.server.on(\"request\", (request, response) =&gt; { this.pcolInstance = new HttpServerProtocol( this, request, response, this.options.version, this.options.delimiter ); this.pcolInstance.clientConnected(); }); } /** * Set response header and response code * @param {object} options * @param {class} options.response Http response instance * @param {boolean} options.notification Inidicate if setting header for notification * @private */ _setResponseHeader({ response, errorCode, notification }) { let statusCode = 200; if (notification) { statusCode = 204; } const header = { \"Content-Type\": \"application/json\" }; if (errorCode) { statusCode = errorToStatus[String(errorCode)]; } response.writeHead(statusCode, header); } } module.exports = HttpServerFactory; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"server_index.js.html":{"id":"server_index.js.html","title":"Source: server/index.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: server/index.js const EventEmitter = require(\"events\"); const { formatResponse } = require(\"../util/format\"); /** * Creates an instance of JsonRpcServerFactory * @extends events */ class JsonRpcServerFactory extends EventEmitter { /** * @param {object} options * @param {Object} [options.host] Host IP to open server with * @param {Object} [options.port] Host port to open server with * @param {Number} [options.version=2] JSON-RPC version to use (1|2) * @param {String} [options.delimiter=\"\\n\"] Delimiter to use for [JsonRpcServerProtocol]{@link JsonRpcServerProtocol} * @param {Boolean} [options.exlusive=false] disallow port sharing * @property {object} methods Key value pairs of server method to function call * @property {array} connectedClients List of connected clients * @property {boolean} listening Inidicates if the server is currently listening * @property {class} pcolInstance Instance of [JsonRpcServerProtocol]{@link JsonRpcServerProtocol} */ constructor(options) { super(); if (!(this instanceof JsonRpcServerFactory)) { return new JsonRpcServerFactory(options); } const defaults = { host: \"127.0.0.1\", port: 8100, exclusive: false, version: \"2.0\", delimiter: \"\\n\" }; this.options = { ...defaults, ...(options || {}) }; this.methods = {}; this.connectedClients = []; this.listening = false; this.pcolInstance = undefined; } /** * Start listening for client connections to server. * * @returns {Promise} */ listen() { return new Promise((resolve, reject) =&gt; { if (this.listening) { // not having this caused MaxEventListeners error return reject(Error(\"server already listening\")); } const { host, port, exclusive } = this.options; this.setServer(); this.server.listen({ host, port, exclusive }); this.server.on(\"listening\", () =&gt; { this.listening = true; this.buildProtocol(); resolve({ host: this.server.address().address, port: this.server.address().port }); }); this.setupListeners(); }); } /** * Set the `pcolInstance` for the server factory * @abstract * @example * this.pcolInstance = new JsonRpcClientProtocol() */ buildProtocol() { throw new Error(\"function must be overwritten in subclass\"); } /** * Set the `server` property for the server factory * @abstract * @example * this.server = new net.Server() */ setServer() { throw new Error(\"function must be overwritten in subclass\"); } /** * Setup the `error` and `close` events for the factory and server. * Sets `listening` to false if any errors returned or if server stops listening. * * Calls the [JsonRpcServerFactory]{@link JsonRpcServerFactory#clientConnected} and * [JsonRpcServerFactory]{@link JsonRpcServerFactory#clientDisconnected} methods * */ setupListeners() { this.on(\"error\", (error) =&gt; { this.listening = false; throw error; }); this.server.on(\"error\", (error) =&gt; { this.listening = false; throw error; }); this.server.on(\"close\", () =&gt; { this.listening = false; }); this.on(\"clientConnected\", (client) =&gt; { this.clientConnected({ host: client.remoteAddress, port: client.remotePort }); }); this.on(\"clientDisconnected\", (client) =&gt; { const clientIndex = this.connectedClients.findIndex((c) =&gt; client === c); if (clientIndex === -1) { this.clientDisconnected({ error: `Unknown client ${JSON.stringify(client)}` }); } else { const [deletedClient] = this.connectedClients.splice(clientIndex, 1); this.clientDisconnected({ host: deletedClient.remoteAddress, port: deletedClient.remotePort }); } }); } /** * Close the server connection. Stops listening. * * @returns {Promise} */ close() { this.listening = false; return new Promise((resolve, reject) =&gt; { this.server.close((error) =&gt; { if (error) { reject(error); } resolve(); }); }); } /** * Register a method and associated function with the server. * * The function will be called when a client makes a request to this method. * * @param {string} name Name of method * @param {function} cb Function to call when client makes request to method */ method(name, cb) { this.methods[name] = cb; } /** * Call function when notification with event name comes in. * * @param {string} method Method name to listen for notification * @param {function} cb Name of callback function fired when method event comes in * @example * function world(){ * return 'foo' * } * server.onNotify(\"hello\", world) */ onNotify(method, cb) { this.on(method, cb); } /** * Remove function name from listening for notifications. * * @param {string} method Method name to remove * @param {function} cb Name of the callback function to remove * @example * function world(){ * return 'foo' * } * server.removeOnNotify(\"hello\", world) */ removeOnNotify(method, cb) { this.removeListener(method, cb); } /** * Remove all functions listening for event name. * * @param {string} method Method name to remove events for */ removeAllOnNotify(method) { this.removeAllListeners([method]); } /** * @param {Array.&lt;Array.&lt;string, Array|object&gt;&gt;} notifications Array of notifications * @returns {boolean[]|Error[]} Returns list of error objects if there was an error sending to any client. * Returns true if the entire data was sent successfully * Returns false if all or part of the data was not sent to the client. * @example * server.notify([ * [\"hello\", [\"world\"]], * [\"foo\", {\"bar\": \"baz\"}] * ]) */ notify(notifications) { if (notifications.length === 0 || !Array.isArray(notifications)) { throw new Error(\"Invalid arguments\"); } const responses = this._getNotificationResponses(notifications); if (responses.length === 0) { throw new Error(\"Unable to generate a response object\"); } let response; if (responses.length === 1) { response = formatResponse(responses[0]); } else { // batch notification responses response = \"[\"; responses.forEach((res, idx) =&gt; { response += formatResponse(res); response += idx === responses.length - 1 ? \"\" : \",\"; }); response += \"]\"; } if (this.connectedClients.length === 0) { return [Error(\"No clients connected\")]; } return this.connectedClients.map((client) =&gt; { try { return this.sendNotification(client, response); } catch (e) { console.log(\"here\"); // possibly client disconnected return e; } }); } /** * Generate objects for notifications to send to client * * @param {Array.&lt;string, Array&gt;} notifications Array of notifications to send to client. * @private */ _getNotificationResponses(notifications) { return notifications.map(([method, params]) =&gt; { if (!method &amp;&amp; !params) { throw new Error(\"Unable to generate a response object\"); } const response = { method, params, delimiter: this.options.delimiter }; if (this.options.version === \"2.0\") { response.jsonrpc = \"2.0\"; } return response; }); } /** * Called when `clientConnected` event is fired. * * @param {object} event Returns host and port or error object */ clientConnected(event) { return event; } /** * Called when `clientDisconnected` event is fired. * * @param {object} event Returns host and port or error object */ clientDisconnected(event) { return event; } } module.exports = JsonRpcServerFactory; /** * HTTP server constructor * @type HttpServerFactory * @static */ JsonRpcServerFactory.http = require(\"./http\"); /** * TCP server constructor * @type TcpServerFactory * @static */ JsonRpcServerFactory.tcp = require(\"./tcp\"); /** * WS server constructor * @type WsServerFactory * @static */ JsonRpcServerFactory.ws = require(\"./ws\"); × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"server_protocol_http.js.html":{"id":"server_protocol_http.js.html","title":"Source: server/protocol/http.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: server/protocol/http.js const JsonRpcServerProtocol = require(\"./base\"); /** * Creates instance of HttpServerProtocol * @extends JsonRpcServerProtocol * */ class HttpServerProtocol extends JsonRpcServerProtocol { /** @inheritdoc */ /** * @property {class} response HTTP response object * */ constructor(factory, client, response, version, delimiter) { super(factory, client, version, delimiter); this.response = response; } /** * Send message to the client. If a notification is passed, then * a 204 response code is sent. * * @param {string} message Stringified JSON-RPC message object * @param {boolean} notification Indicates if message is a notification */ writeToClient(message, notification) { if (notification) { this.factory._setResponseHeader({ response: this.response, notification: true }); this.response.end(); return; } this.factory._setResponseHeader({ response: this.response }); this.response.write(message, () =&gt; { this.response.end(); }); } /** * Calls `emit` on factory with the event name being `message.method` and * the date being `message`. Responds to client. * * @param {string} message Stringified JSON-RPC message object */ gotNotification(message) { super.gotNotification(message.method, message); this.writeToClient(message, true); } /** @inheritdoc */ clientConnected() { this.client.on(this.event, (data) =&gt; { this.messageBuffer.push(data); }); this.client.on(\"end\", () =&gt; { this._waitForData(); }); } } module.exports = HttpServerProtocol; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"server_protocol_base.js.html":{"id":"server_protocol_base.js.html","title":"Source: server/protocol/base.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: server/protocol/base.js const MessageBuffer = require(\"../../util/buffer\"); const { formatResponse, formatError } = require(\"../../util/format\"); const { ERR_CODES, ERR_MSGS } = require(\"../../util/constants\"); /** * Creates an instance of JsonRpcServerProtocol. This is the * base protocol from which all others inherit. * */ class JsonRpcServerProtocol { /** * @param {class} factory Instance of [JsonRpcServerFactory]{@link JsonRpcServerFactory} * @param {class} client Instance of `net.Socket` * @param {string|number} version JSON-RPC version to use * @param {string} delimiter Delimiter to use for `messageBuffer` * @property {class} messageBuffer Instance of [MessageBuffer]{@link MessageBuffer} * @property {string} event=\"data\" The event name to listen for incoming data */ constructor(factory, client, version, delimiter) { this.client = client; this.factory = factory; this.delimiter = delimiter; this.version = version; this.messageBuffer = new MessageBuffer(delimiter); this.event = \"data\"; } /** * Registers the `event` listener when client connects. * * Pushes received data into `messageBuffer` and calls * [_waitForData]{@link JsonRpcServerProtocol#_waitForData}. * * Registers `end` event to emit a `clientDisconnected` event * on the factory * */ clientConnected() { this.client.on(this.event, (data) =&gt; { this.messageBuffer.push(data); this._waitForData(); }); this.client.on(\"end\", () =&gt; { this.factory.emit(\"clientDisconnected\", this.client); }); } /** * Accumulate data while [MessageBuffer.isFinished]{@link MessageBuffer#isFinished} is returning false. * * If the buffer returns a message it will be passed to [validateRequest]{@link JsonRpcServerProtocol#validateRequest}. * If [validateRequest]{@link JsonRpcServerProtocol#validateRequest} returns a parsed result, then the result * is passed to [_maybeHandleRequest]{@link JsonRpcServerProtocol#_maybeHandleRequest}. * If [_maybeHandleRequest]{@link JsonRpcServerProtocol#_maybeHandleRequest} returns true, then * [gotRequest]{@link JsonRpcServerProtocol#gotRequest} is called.&lt;br/&gt;&lt;br/&gt; * * If any of the above throws an error, [gotError]{@link JsonRpcServerProtocol#gotError} is called. * * @private * */ _waitForData() { while (!this.messageBuffer.isFinished()) { const chunk = this.messageBuffer.handleData(); try { const result = this.validateRequest(chunk); const isMessage = this._maybeHandleRequest(result); if (isMessage) { this.gotRequest(result); } } catch (e) { this.gotError(e); } } } /** * Validate the incoming data returned from `messageBuffer` * * @param {string} chunk * @return {JSON} * @throws Will throw an error with a JSON-RPC error object if chunk cannot be parsed */ validateRequest(chunk) { try { return JSON.parse(chunk); } catch (e) { throw new Error( formatError({ jsonrpc: this.version, id: null, code: ERR_CODES.parseError, message: ERR_MSGS.parseError, delimiter: this.delimiter }) ); } } /** * Determines the type of request being made (batch, notification, request) and * calls the corresponding function. * * @param {JSON} result Valid JSON-RPC request object * @private */ _maybeHandleRequest(result) { if (Array.isArray(result)) { if (result.length === 0) { return this.writeToClient( formatError({ code: ERR_CODES.invalidRequest, message: ERR_MSGS.invalidRequest, delimiter: this.delimiter, jsonrpc: this.version, id: null }) ); } // possible batch request this.gotBatchRequest(result).then((res) =&gt; { this.writeToClient(JSON.stringify(res) + this.delimiter); }); } else if (result === Object(result) &amp;&amp; !(\"id\" in result)) { // no id, so assume notification this.gotNotification(result); } else { this.validateMessage(result); return true; } } /** * Validates if there are any issues with the incoming request&lt;br/&gt; * * * @param {JSON} message Valid JSON-RPC request object * @throws Will throw an error for any of the below reasons * * Reason|Type * ---|--- * message is not an object| Invalid Request * the server does not have the required method| Method Not Found * the params are not an array or object| Invalid Params * the \"jsonrpc\" property was passed for a v1 server| Invalid Request */ validateMessage(message) { if (!(message === Object(message))) { this._raiseError(ERR_MSGS.invalidRequest, ERR_CODES.invalidRequest, null); } else if (!(typeof message.method === \"string\")) { this._raiseError( ERR_MSGS.invalidRequest, ERR_CODES.invalidRequest, message.id ); } else if (!(message.method in this.factory.methods)) { this._raiseError( ERR_MSGS.methodNotFound, ERR_CODES.methodNotFound, message.id ); } else if ( message.params &amp;&amp; !Array.isArray(message.params) &amp;&amp; !(message.params === Object(message.params)) ) { this._raiseError( ERR_MSGS.invalidParams, ERR_CODES.invalidParams, message.id ); } else if (message.jsonrpc &amp;&amp; this.version !== \"2.0\") { this._raiseError( ERR_MSGS.invalidRequest, ERR_CODES.invalidRequest, message.id ); } } /** * Send message to the client * * @param {string} message Stringified JSON-RPC message object */ writeToClient(message) { this.client.write(message); } /** * Calls `emit` on factory with the event name being `message.method` and * the date being `message`. * * @param {string} message Stringified JSON-RPC message object */ gotNotification(message) { this.factory.emit(message.method, message); } /** * Attempts to get the result for the request object. Will * send result to client if successful and will send an error * otherwise. * * @param {JSON} message JSON-RPC message object * @returns {Promise} */ gotRequest(message) { return this.getResult(message) .then((result) =&gt; { this.writeToClient(result); }) .catch((error) =&gt; { this.gotError(Error(error)); }); } /** * Attempts to get the result for all requests in the batch. * Will send result to client if successful and error otherwise. * * @param {JSON[]} requests Valid JSON-RPC batch request * @returns {Promise[]} */ gotBatchRequest(requests) { const batchResponses = requests .map((request) =&gt; { try { this._maybeHandleRequest(request); return this.getResult(request) .then((result) =&gt; JSON.parse(result)) .catch((error) =&gt; JSON.parse(error)); } catch (e) { // basically reject the whole batch if any one thing fails return JSON.parse(e.message); } }) .filter((el) =&gt; el != null); return Promise.all(batchResponses); } /** * Get the result for the request. Calls the function associated * with the method and returns the result. * * @param {JSON} message Valid JSON-RPC message object * @returns {Promise} */ getResult(message) { // function needs to be async since the method can be a promise return new Promise((resolve, reject) =&gt; { const { params } = message; const response = { jsonrpc: message.jsonrpc, id: message.id, delimiter: this.delimiter }; const error = { jsonrpc: message.jsonrpc, id: message.id, delimiter: this.delimiter }; try { const result = params ? this.factory.methods[message.method](params) : this.factory.methods[message.method](); if (result instanceof Promise || typeof result.then === \"function\") { Promise.all([result]) .then((results) =&gt; { response.result = results || 0; resolve(formatResponse(response)); }) .catch((resError) =&gt; { error.code = ERR_CODES.internal; error.message = `${JSON.stringify(resError.message || resError)}`; reject(formatError(error)); }); } else { response.result = result || 0; resolve(formatResponse(response)); } } catch (e) { if (e instanceof TypeError) { error.code = ERR_CODES.invalidParams; error.message = ERR_MSGS.invalidParams; // error.data = e.message; } else { error.code = ERR_CODES.unknown; error.message = ERR_MSGS.unknown; // error.data = e.message; } reject(formatError(error)); } }); } /** * * @param {string} message Error message * @param {number} code Error code * @param {string|number} id Error message ID * @throws Throws a JSON-RPC error object * @private */ _raiseError(message, code, id) { const error = formatError({ jsonrpc: this.version, delimiter: this.delimiter, id, code, message }); throw new Error(error); } /** * Writes error to the client. Will send a JSON-RPC error object if the * passed error cannot be parsed. * * @param {string} error Stringified error object */ gotError(error) { let err; try { err = JSON.stringify(JSON.parse(error.message)); } catch (e) { err = formatError({ jsonrpc: this.version, delimiter: this.delimiter, id: null, code: ERR_CODES.unknown, message: JSON.stringify(error, Object.getOwnPropertyNames(error)) }); } this.writeToClient(err + this.delimiter); } } module.exports = JsonRpcServerProtocol; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: index.js /** * Namespace available as require('jaysonic') * @namespace Jaysonic */ const Jaysonic = module.exports; /** * @static * @type JsonRpcClientFactory */ Jaysonic.client = require(\"./client\"); /** * @static * @type JsonRpcServerFactory */ Jaysonic.server = require(\"./server\"); × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"client-ws_index.js.html":{"id":"client-ws_index.js.html","title":"Source: client-ws/index.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: client-ws/index.js const Jaysonic = module.exports; /** * Websocket Browser Client constructor * @type WsBrowserClientFactory * @static */ Jaysonic.wsclient = require(\"./ws\"); × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"util_buffer.js.html":{"id":"util_buffer.js.html","title":"Source: util/buffer.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: util/buffer.js /** * Creates an instance of MessageBuffer.&lt;br/&gt; * * The buffer accumulates received data and returns true or false for when a delimiter has been recieved.&lt;br/&gt; * * If a delimiter is recieved into the buffer, the message up to that point can be * removed from the buffer and returned. * * @example * // We can receive whole messages or parital, so we need to buffer * * {\"jsonrpc\": 2.0, \"params\": [\"hello\"], id: 1}\\n // whole message * // or * {\"jsonrpc\": 2.0, \"params\" // partial message */ class MessageBuffer { /** * @param {string} delimiter The delimiter to use to determine if a message is complete * @example * const messageBuffer = new MessageBuffer('\\n') */ constructor(delimiter) { this.delimiter = delimiter; this.buffer = \"\"; } /** * Used to determine if the buffer is empty. Buffer is considered * empty if its an empty string or contains no delimiter * * @returns {boolean} * @example * while(!messageBuffer.isFinished()){ * // get current data and verify * } */ isFinished() { if ( this.buffer.length === 0 || this.buffer.indexOf(this.delimiter) === -1 ) { return true; } return false; } /** * Accumulate the buffer with messages. * * If the server isnt sending delimiters for some reason * then nothing will ever come back for these requests. * * @param {string} data Data to push into buffer * @example * messageBuffer.push(\"hello\\n\") */ push(data) { this.buffer += data; } /** * Return the message from the buffer if delimiter is found, and null otherwise. * * The message is everything before the delimiter. * * Replace message string in buffer with empty string. * * @returns {string|null} message * @example * const message = messageBuffer.getMessage() * console.log(message) // \"hello\" * */ getMessage() { const delimiterIndex = this.buffer.indexOf(this.delimiter); if (delimiterIndex !== -1) { const message = this.buffer.slice(0, delimiterIndex); this.buffer = this.buffer.replace(message + this.delimiter, \"\"); return message; } return null; } /** * @returns {function} MessageBuffer.getMessage() */ handleData() { return this.getMessage(); } } module.exports = MessageBuffer; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"util_format.js.html":{"id":"util_format.js.html","title":"Source: util/format.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: util/format.js /** * Generates a stringified JSON-RPC request object with appended delimiter. * * @function formatRequest * @memberof Utils.format * @param {object} request * @param {string} request.method * @param {array|object} request.params * @param {string|number} request.id * @param {string|number} request.version * @param {string} request.delimiter */ const formatRequest = ({ method, params, id, version, delimiter }) =&gt; { if (!(typeof method === \"string\")) { throw new TypeError(`${method} must be a string`); } const request = { method }; // assume 2.0 request unless otherwise specified if (!version || version !== 1) { request.jsonrpc = \"2.0\"; } if ( (params &amp;&amp; !(params === Object(params)) &amp;&amp; !Array.isArray(params)) || typeof params === \"function\" ) { throw new TypeError(`${params} must be an object or array`); } else if (params) { request.params = params; } // assume notification otherwise if (!(typeof id === \"undefined\")) { request.id = id; } return JSON.stringify(request) + delimiter; }; /** * Generates a stringified JSON-RPC response object with appended delimiter. * * @function formatResponse * @memberof Utils.format * @param {object} response * @param {string} response.method * @param {array|object} response.params * @param {string|number} response.id * @param {string|number} response.jsonrpc * @param {string} response.delimiter * @param response.result */ const formatResponse = ({ jsonrpc, id, method, result, params, delimiter }) =&gt; { const response = {}; if (params &amp;&amp; result) { throw new Error(\"Cannot send response with both params and result\"); } if (method &amp;&amp; id) { throw new Error(\"Cannot send response with both a method and non-null id\"); } if (method &amp;&amp; !(typeof method === \"string\")) { throw new TypeError(`${method} must be a string`); } if ( (params &amp;&amp; !(params === Object(params)) &amp;&amp; !Array.isArray(params)) || typeof params === \"function\" ) { throw new TypeError(`${params} must be an object or array`); } else if (params) { response.params = params; } if (result) { response.result = result; } if (!jsonrpc) { // 1.0 response response.error = null; } else { // assume 2.0 response, dont include null error and include jsonrpc version response.jsonrpc = \"2.0\"; } if (!id) { if (method) { response.method = method; } if (!jsonrpc) { response.id = null; } } else { response.id = id; } return JSON.stringify(response) + delimiter; }; /** * Generates a stringified JSON-RPC error object with appended delimiter. * * @function formatError * @memberof Utils.format * @param {object} error * @param {string} error.message * @param {array|object} error.code * @param {string|number} error.id * @param {string|number} error.jsonrpc * @param {string} error.delimiter * @param {string|object|array} error.data */ const formatError = ({ jsonrpc, id, code, message, data, delimiter }) =&gt; { if (!message) { throw new Error(\"Must include message in error response\"); } const response = jsonrpc === \"2.0\" ? { jsonrpc, error: { code, message }, id } : { result: null, error: { code, message }, id }; if (data) { response.error.data = data; } return JSON.stringify(response) + delimiter; }; /** * @static * */ module.exports = { formatRequest, formatResponse, formatError }; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"client_tcp.js.html":{"id":"client_tcp.js.html","title":"Source: client/tcp.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: client/tcp.js const JsonRpcClientFactory = require(\".\"); const TcpClientProtocol = require(\"./protocol/tcp\"); /** * Creates instance of TcpClientFactory * * @extends JsonRpcClientFactory */ class TcpClientFactory extends JsonRpcClientFactory { /** @inheritdoc */ connect() { if (this.pcolInstance) { // not having this caused MaxEventListeners error return Promise.reject(Error(\"client already connected\")); } this.pcolInstance = new TcpClientProtocol( this, this.options.version, this.options.delimiter ); return this.pcolInstance.connect(); } /** @inheritdoc */ end(cb) { this.pcolInstance.end(cb); } /** @inheritdoc */ subscribe(method, cb) { this.on(method, cb); } /** @inheritdoc */ unsubscribe(method, cb) { this.removeListener(method, cb); } /** @inheritdoc */ unsubscribeAll(method) { this.removeAllListeners([method]); } } module.exports = TcpClientFactory; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"client_protocol_tcp.js.html":{"id":"client_protocol_tcp.js.html","title":"Source: client/protocol/tcp.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: client/protocol/tcp.js const net = require(\"net\"); const JsonRpcClientProtocol = require(\"./base\"); /** * Creates an instance of TcpClientProtocol * * @extends JsonRpcClientProtocol * @requires net */ class TcpClientProtocol extends JsonRpcClientProtocol { /** * Set the `connector` attribute for the [JsonRpcClientProtocol]{@link JsonRpcClientProtocol} instance. The connector is essentially the * socket instance for the client. * * For the [TcpClientProtocol]{@link TcpClientProtocol} this is `net.Socket()` */ setConnector() { this.connector = new net.Socket(); } } module.exports = TcpClientProtocol; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:27-04:00 using the DocStrap template. "},"server_tcp.js.html":{"id":"server_tcp.js.html","title":"Source: server/tcp.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: server/tcp.js const net = require(\"net\"); const JsonRpcServerFactory = require(\".\"); const TCPServerProtocol = require(\"./protocol/tcp\"); /** * Creates an instance of TcpServerFactory * @extends JsonRpcServerFactory */ class TcpServerFactory extends JsonRpcServerFactory { /** @inheritdoc */ setServer() { this.server = new net.Server(); } /** @inheritdoc */ buildProtocol() { this.server.on(\"connection\", (client) =&gt; { this.connectedClients.push(client); this.emit(\"clientConnected\", client); this.pcolInstance = new TCPServerProtocol( this, client, this.options.version, this.options.delimiter ); this.pcolInstance.clientConnected(); }); } /** * Send notification to client * * @param {class} client Client instance * @param {string} response Stringified JSON-RPC message to sent to client * @throws Will throw an error if client is not defined */ sendNotification(client, response) { return client.write( JSON.stringify(JSON.parse(response)) + this.options.delimiter ); } } module.exports = TcpServerFactory; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"server_protocol_tcp.js.html":{"id":"server_protocol_tcp.js.html","title":"Source: server/protocol/tcp.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: server/protocol/tcp.js const JsonRpcServerProtocol = require(\"./base\"); /** * Creates instance of TcpServerProtocol * @extends JsonRpcServerProtocol */ class TcpServerProtocol extends JsonRpcServerProtocol {} module.exports = TcpServerProtocol; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"util_index.js.html":{"id":"util_index.js.html","title":"Source: util/index.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: util/index.js /** * @namespace Utils */ const Utils = module.exports; /** * @static * @type MessageBuffer */ Utils.MessageBuffer = require(\"./buffer\"); /** * Generate a valid JSON-RPC request, response or error object * with an appended delimiter. * * @static * @namespace Utils.format */ Utils.format = require(\"./format\"); /** * @static * @namespace Utils.constants */ Utils.constants = require(\"./constants\"); × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"util_constants.js.html":{"id":"util_constants.js.html","title":"Source: util/constants.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: util/constants.js /** * @property {object} ERR_CODES * @property {number} ERR_CODES.parseError -32700 * @property {number} ERR_CODES.invalidRequest -32600 * @property {number} ERR_CODES.methodNotFound -32601 * @property {number} ERR_CODES.invalidParams -32602 * @property {number} ERR_CODES.internal -32603 * @property {number} ERR_CODES.timeout -32000 * @property {number} ERR_CODES.unknown -32001 * @memberof Utils.constants * */ const ERR_CODES = { parseError: -32700, invalidRequest: -32600, methodNotFound: -32601, invalidParams: -32602, internal: -32603, timeout: -32000, unknown: -32001 }; /** * @property {object} ERR_MSGS * @property {string} ERR_CODES.parseError \"Parse Error\" * @property {string} ERR_CODES.invalidRequest \"Invalid Request\" * @property {string} ERR_CODES.methodNotFound \"Method not found\" * @property {string} ERR_CODES.invalidParams \"Invalid Parameters\" * @property {string} ERR_CODES.internal \"Internal Error\" * @property {string} ERR_CODES.timeout \"Request Timeout\" * @property {string} ERR_CODES.unknown \"Unknown Error\" * @memberof Utils.constants */ const ERR_MSGS = { parseError: \"Parse Error\", invalidRequest: \"Invalid Request\", methodNotFound: \"Method not found\", invalidParams: \"Invalid Parameters\", internal: \"Internal Error\", timeout: \"Request Timeout\", unknown: \"Unknown Error\" }; /** * Returns HTTP status code for a given error code * @property {object} errorToStatus * @property {number} errorToStatus.-32700 500 * @property {number} errorToStatus.-32600 400 * @property {number} errorToStatus.-32601 404 * @property {number} errorToStatus.-32602 500 * @property {number} errorToStatus.-32603 500 * @property {number} errorToStatus.-32000 408 * @property {number} errorToStatus.-32001 500 * @memberof Utils.constants */ const errorToStatus = { \"-32700\": 500, \"-32600\": 400, \"-32601\": 404, \"-32602\": 500, \"-32603\": 500, \"-32000\": 408, \"-32001\": 500 }; module.exports = { ERR_CODES, ERR_MSGS, errorToStatus }; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"client-ws_ws.js.html":{"id":"client-ws_ws.js.html","title":"Source: client-ws/ws.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: client-ws/ws.js /* eslint no-console: 0 */ const WsBrowserClientProtocol = require(\"../client/protocol/ws-browser\"); /** * Creates an instance of WsBrowserClientFactory. * * For websocket client use in the browser. * * @extends EventTarget */ class WsBrowserClientFactory extends EventTarget { /** * @inheritdoc * @param {Object} options Connection options for the factory class * @param {string} [options.url=\"ws://127.0.0.1:8100\"] IP of server to connect to * @param {number} [options.version=2] JSON-RPC version to use (1|2) * @param {string} [options.delimiter=\"\\n\"] Delimiter to use for requests * @param {number} [options.timeout=30] Timeout for request response * @param {number} [options.connectionTimeout=5000] Timeout for connection to server * @param {number} [options.retries=2] Number of connection retry attempts * @property {class} pcolInstance The [JsonRpcClientProtocol]{@link JsonRpcClientProtocol} instance * @property {object} timeouts Key value pairs of request IDs to `setTimeout` instance * @property {number} requestTimeout Same as `options.timeout` * @property {number} remainingRetries Same as `options.retries` * @property {number} connectionTimeout Same as `options.connectionTimeout` * @property {string} url Same as `options.url` */ constructor(options) { super(); if (!(this instanceof WsBrowserClientFactory)) { return new WsBrowserClientFactory(options); } const defaults = { url: \"ws://127.0.0.1:8100\", version: \"2.0\", delimiter: \"\\n\", timeout: 30, connectionTimeout: 5000, retries: 2 }; this.options = { ...defaults, ...(options || {}) }; this.pcolInstance = undefined; this.timeouts = {}; this.url = this.options.url; this.eventListenerList = {}; this.requestTimeout = this.options.timeout * 1000; this.remainingRetries = this.options.retries; this.connectionTimeout = this.options.connectionTimeout; } /** * Calls `connect()` on protocol instance * */ connect() { if (this.pcolInstance) { // not having this caused MaxEventListeners error return Promise.reject(Error(\"client already connected\")); } this.pcolInstance = new WsBrowserClientProtocol( this, this.options.version, this.options.delimiter ); return this.pcolInstance.connect(); } /** * Calls `end()` on protocol instance * */ end(cb) { this.pcolInstance.end(cb); } /** * Calls `request()` method on protocol instance */ request() { return this.pcolInstance.request(); } /** * Calls `batch()` method on protocol instance * * @param {JSON[]} requests Valid JSON-RPC batch request array */ batch(requests) { return this.pcolInstance.batch(requests); } /** * Clears pending timeouts kept in `timeouts` for the provided request IDs. * * @param {string[]|number[]} ids Array of request IDs */ cleanUp(ids) { // clear pending timeouts for these request ids clearTimeout(this.timeouts[ids]); delete this.timeouts[ids]; } /** * Subscribe the function to the given event name * * @param {string} method Method to subscribe to * @param {function} cb Name of callback function to invoke on event * @abstract */ subscribe(method, cb) { if (!this.eventListenerList) this.eventListenerList = {}; if (!this.eventListenerList[method]) this.eventListenerList[method] = []; // add listener to event tracking list this.eventListenerList[method].push({ type: method, listener: cb }); this.addEventListener(method, cb); } /** * Unsubscribe the function from the given event name * * @param {string} method Method to unsubscribe from * @param {function} cb Name of function to remove * @abstract */ unsubscribe(method, cb) { // remove listener this.removeEventListener(method, cb); // Find the event in the list and remove it this._removeListener(method, cb); // if no more events of the removed event method are left,remove the group if (this.eventListenerList[method].length === 0) { delete this.eventListenerList[method]; } } /** * Unsubscribe all functions from given event name * * @param {string} method Method to unsubscribe all listeners from * @abstract */ unsubscribeAll(method) { if (!this.eventListenerList) { this.eventListenerList = {}; } if (!this.eventListenerList[method]) { this.eventListenerList[method] = []; } // remove listener for (let j = 0; j &lt; this.eventListenerList[method].length; j += 1) { const cb = this.eventListenerList[method][j].listener; // remove listener this.removeEventListener(method, cb); // Find the event in the list and remove it this._removeListener(method, cb); } delete this.eventListenerList[method]; } _removeListener(method, cb) { if (!this.eventListenerList) { this.eventListenerList = {}; } if (!this.eventListenerList[method]) { this.eventListenerList[method] = []; } for (let i = 0; i &lt; this.eventListenerList[method].length; i += 1) { if (this.eventListenerList[method][i].listener === cb) { this.eventListenerList[method].splice(i, 1); break; } } } getEventListeners(type) { if (!this.eventListenerList) { this.eventListenerList = {}; } // return requested listeners type or all them if (type === undefined) { return this.eventListenerList; } return this.eventListenerList[type]; } } module.exports = WsBrowserClientFactory; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"client_protocol_ws-browser.js.html":{"id":"client_protocol_ws-browser.js.html","title":"Source: client/protocol/ws-browser.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: client/protocol/ws-browser.js const WsClientProtocol = require(\"./ws\"); /** * Creates an instance of WsBrowserClientProtocol * * @extends WsClientProtocol */ class WsBrowserClientProtocol extends WsClientProtocol { /** * Set the `connector` attribute for the protocol instance. The connector is essentially the * socket instance for the client. * * For the [WsBrowserClientProtocol]{@link WsBrowserClientProtocol} this is `window.WebSocket()` */ setConnector() { const { protocols } = this.factory.options; this.connector = new window.WebSocket(this.url, protocols); } /** @inheritdoc */ gotBatch(message) { // check if any requests are notifications message.forEach((res) =&gt; { if (res &amp;&amp; res.method &amp;&amp; !res.id) { this.factory.dispatchEvent( new CustomEvent(res.method, { detail: res }) ); } }); this.gotBatchResponse(message); } /** @inheritdoc */ gotNotification(message) { this.factory.dispatchEvent( new CustomEvent(message.method, { detail: message }) ); } } module.exports = WsBrowserClientProtocol; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"client_ws.js.html":{"id":"client_ws.js.html","title":"Source: client/ws.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: client/ws.js const JsonRpcClientFactory = require(\".\"); const WsClientProtocol = require(\"./protocol/ws\"); /** * Creates instance of WsClientFactory * * @extends JsonRpcClientFactory */ class WsClientFactory extends JsonRpcClientFactory { /** * Additional parameters ontop of those inherited from [JsonRpcClientFactory]{@link JsonRpcClientFactory} * @param {object} options Connection options for factory class * @param {string} [options.url=\"ws://127.0.0.1:8100\"] Websocket URL to connect to * @property {string} url Same as `options.url` */ constructor(options) { super(options); if (!(this instanceof WsClientFactory)) { return new WsClientFactory(options); } const defaults = { url: \"ws://127.0.0.1:8100\" }; this.options = { ...defaults, ...(this.options || {}) }; this.url = this.options.url; } /** @inheritdoc */ connect() { if (this.pcolInstance) { // not having this caused MaxEventListeners error return Promise.reject(Error(\"client already connected\")); } this.pcolInstance = new WsClientProtocol( this, this.options.version, this.options.delimiter ); return this.pcolInstance.connect(); } /** @inheritdoc */ end(cb) { this.pcolInstance.end(cb); } /** @inheritdoc */ subscribe(method, cb) { this.on(method, cb); } /** @inheritdoc */ unsubscribe(method, cb) { this.removeListener(method, cb); } /** @inheritdoc */ unsubscribeAll(method) { this.removeAllListeners([method]); } } module.exports = WsClientFactory; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"client_protocol_ws.js.html":{"id":"client_protocol_ws.js.html","title":"Source: client/protocol/ws.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: client/protocol/ws.js const WebSocket = require(\"ws\"); const JsonRpcClientProtocol = require(\"./base\"); /** * Creates and instance of WsClientProtocol * * @extends JsonRpcClientProtocol * @requires ws */ class WsClientProtocol extends JsonRpcClientProtocol { /** @inheritdoc */ /** @property {string} url The websocket URL to connect to, i.e. `ws://127.0.0.1:8100` */ constructor(factory, version, delimiter) { super(factory, version, delimiter); this.url = this.factory.url; } /** * Set the `connector` attribute for the protocol instance. The connector is essentially the * socket instance for the client. * * For the [WsClientProtocol]{@link WsClientProtocol} this is `WebSocket()` */ setConnector() { const { perMessageDeflate } = this.factory.options; this.connector = new WebSocket(this.url, perMessageDeflate); } /** * @inheritdoc */ connect() { return new Promise((resolve, reject) =&gt; { const retryConnection = () =&gt; { this.setConnector(); this.connector.onopen = (event) =&gt; { this.connector.write = this.connector.send; // tcp uses .write(), ws uses .send() this.listener = this.connector; this.listen(); resolve(event); }; this.connector.onerror = (error) =&gt; { // let the onclose event got it otherwise if (error.error.code !== \"ECONNREFUSED\") { reject(error); } }; this.connector.onclose = (event) =&gt; { if (this.connector.__clientClosed) { console.log( `Client closed connection. Code[${event.code}]. Reason [${event.message}]` ); } else { if (this.factory.remainingRetries === 0) { reject(event); } this.factory.remainingRetries -= 1; console.error( `Connection failed. ${this.factory.remainingRetries} attempts left.` ); setTimeout(() =&gt; { retryConnection(); }, this.factory.connectionTimeout); } }; }; return retryConnection(); }); } /** @inheritdoc */ end(code, reason) { this.factory.pcolInstance = undefined; this.connector.__clientClosed = true; this.connector.close(code, reason); } /** @inheritdoc */ listen() { this.listener.onmessage = (message) =&gt; { this.messageBuffer.push(message.data); this._waitForData(message.data); }; } } module.exports = WsClientProtocol; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"server_ws.js.html":{"id":"server_ws.js.html","title":"Source: server/ws.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: server/ws.js const WebSocket = require(\"ws\"); const JsonRpcServerFactory = require(\".\"); const WSServerProtocol = require(\"./protocol/ws\"); /** * Creates and instance of WsServerFactory * @extends JsonRpcServerFactory * @requires ws */ class WsServerFactory extends JsonRpcServerFactory { constructor(options) { super(options); const defaults = { path: null, // all the ws options on the github page perMessageDeflate: { zlibDeflateOptions: { // See zlib defaults. chunkSize: 1024, memLevel: 7, level: 3 }, zlibInflateOptions: { chunkSize: 10 * 1024 } } }; this.options = { ...defaults, ...(this.options || {}) }; } /** @inheritdoc */ setSever() { this.server = new WebSocket.Server(this.options); } /** @inheritdoc */ listen() { return new Promise((resolve, reject) =&gt; { if (this.listening) { // not having this caused MaxEventListeners error return reject(Error(\"server already listening\")); } this.setSever(); this.listening = true; this.pcolInstance = this.buildProtocol(); try { resolve({ host: this.options.host, port: this.options.port, path: this.options.path }); } catch (e) { reject(e); } }); } /** @inheritdoc */ buildProtocol() { this.server.on(\"connection\", (client) =&gt; { this.emit(\"clientConnected\", client); this.connectedClients.push(client); this.pcolInstance = new WSServerProtocol( this, client, this.options.version, this.options.delimiter ); this.pcolInstance.clientConnected(); }); } /** * Send notification to client * * @param {class} client Client instance * @param {string} response Stringified JSON-RPC message to sent to client * @throws Will throw an error if client is not defined */ sendNotification(client, response) { return client.send( JSON.stringify(JSON.parse(response)) + this.options.delimiter ); } } module.exports = WsServerFactory; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"server_protocol_ws.js.html":{"id":"server_protocol_ws.js.html","title":"Source: server/protocol/ws.js","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Source: server/protocol/ws.js const JsonRpcServerProtocol = require(\"./base\"); /** * Creates instance of WsServerProtocol * @extends JsonRpcServerProtocol */ class WsServerProtocol extends JsonRpcServerProtocol { /** @inheritdoc */ /** * @property {string} event HTTP response object * @property {object} client.write Overrides `client.write` to use `client.send` for Websocket */ constructor(factory, client, version, delimiter) { super(factory, client, version, delimiter); this.event = \"message\"; // ws uses 'message', tcp uses 'data' this.client.write = this.client.send; // ws uses .send(), tcp uses .write() } } module.exports = WsServerProtocol; × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Classes Classes HttpClientFactory HttpClientProtocol HttpServerFactory HttpServerProtocol JsonRpcClientFactory JsonRpcClientProtocol JsonRpcServerFactory JsonRpcServerProtocol MessageBuffer TcpClientFactory TcpClientProtocol TcpServerFactory TcpServerProtocol WsBrowserClientFactory WsBrowserClientProtocol WsClientFactory WsClientProtocol WsServerFactory WsServerProtocol Namespaces Jaysonic Utils constants format × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Namespaces Classes HttpClientFactory HttpClientProtocol HttpServerFactory HttpServerProtocol JsonRpcClientFactory JsonRpcClientProtocol JsonRpcServerFactory JsonRpcServerProtocol MessageBuffer TcpClientFactory TcpClientProtocol TcpServerFactory TcpServerProtocol WsBrowserClientFactory WsBrowserClientProtocol WsClientFactory WsClientProtocol WsServerFactory WsServerProtocol Namespaces Jaysonic Utils constants format × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Jaysonic - A persistent JSON-RPC client and server List of features Download &amp; Installation Initialization WS Client for browser WS Client for Node Options Code Demos Initialization TCP HTTP WS Server side Instantiation and Listening Closing the connection Adding Methods Listening for client connections Client Side Connecting Listening for server disconnect Making requests Subscriptions Batch Requests HTTP Client Requests Notifications Client Server Batches HTTP Client Notifications Contributing Authors or Acknowledgments License Jaysonic - A persistent JSON-RPC client and server Check Status Travis CI Build Test Coverage Code Maintainability Docs Build A TCP, HTTP and WebSocket server and client library which implements the JSON-RPC 2.0 and 1.0 specifications. Written for nodejs, primarily utilizing ES6 syntax. List of features Promise based Persistent connections Notification subscriptions Batching TCP server/client HTTP server/client WebSocket server/client WebSocket client supported in the browser Automatic increment of request ID Associate response ID with request Download &amp; Installation $ npm install jaysonic Documentation Latest documentation on the methods and classes available in the library https://jaysonic.irowell.io/ Initialization All clients and servers are instantiated with the same syntax, just change the type // TCP const server = new Jaysonic.server.tcp(); const client = new Jaysonic.client.tcp(); // HTTP const server = new Jaysonic.server.http(); const client = new Jaysonic.client.http(); // WS const wss = new Jaysonic.server.ws(); Note that there are two web socket clients One can only be run in the browser, and the other can run in a NodeJS environment. WS Client for browser The browser ws client is based on the window.WebSocket class. const Jaysonic = require(\"jaysonic/lib/client-ws\"); const ws = new Jaysonic.wsclient(); WS Client for Node The Node ws client is based on the ws library (same as the server). const Jaysonic = require(\"jaysonic\"); const ws = new Jaysonic.client.ws(); Options The client and server support changing the JSON-RPC version and the delimiter used. Just pass them in the same object as the host and port to override the defaults. Client and server options host: The host IP to serve from for the server, or to connect to by the client. Default is 127.0.0.1. Note this is only available for the HTTP and TCP server/client. port: The host port to serve from for the server, or to connect to by the client. Default is 8100. delimiter: Delimiter to break requests by. Defaults to \\n. version: RPC version to use. Defaults to 2.0. Client only options retries: The number of retry attempts for the client to connect to the server. Default is 2. timeout: The amount of time before a request times out. Will return a -32000 error code. The default value is 30 (in seconds). connectionTimeout: The amount of time between connection retry attempts to a server. The default value is 5000 (in milliseconds). Other client and server options The TCP and HTTP server have an additional option specified by the NodeJS Docs. exclusive: If exclusive is false (default), then cluster workers will use the same underlying handle, allowing connection handling duties to be shared. When exclusive is true, the handle is not shared, and attempted port sharing results in an error. The HTTP client supports additional options for the HTTP request. method: The method to make the request with. Default is POST. path: The path to send the request to. Default is /. encoding: How to encode the HTTP request. Will factor into content-length calculation. Default is utf-8. headers: Headers to include in the request. Defaults provided by the spec are: \"Content-Length\" calculated by request message, this is not configurable \"Content-Type\" defaults to \"application/json Accept defaults to \"application/json\" The WebSocket client supports an additional option in place of the host property. url: The web socket url to connect to. Default is ws://127.0.0.1:8100. The WebSocket server is based on the ws library (https://github.com/websockets/ws). It supports all of the options listed in their README. Typically changing the port is enough. Code Demos The default host and port for the server is 127.0.0.1:8100. Based on the node net.Server() module. The default host and port for the TCP client is 127.0.0.1:8100. Based on the node net.Socket() module. The default request URL for the HTTP client is http://127.0.0.1:8100/. Based on the node http.ClientRequest module. The default url for the WS client is ws://127.0.0.1:8100. Based on the WebSocket module from JavaScript. The default port for the WS Server is 8100. Based on the ws library. The default options will be used when instantiating the client or the server. Overrides can be provided by passing an object with the modifications. Initialization TCP const Jaysonic = require(\"jaysonic\"); // server with overrides const server = new Jaysonic.server.tcp({ host: \"127.0.0.1\", port: 8100, delimiter: \"\\n\", version: 1 }); HTTP const Jaysonic = require(\"jaysonic\"); // client with overrides const client = new Jaysonic.client.http({ method: \"POST\", headers: { \"Content-Type\": \"application/json; charset=utf-8\", Accept: \"application/json\" }, path: \"/\" }; }); WS wsclient class can only be used in the browser. client.ws cannot be used in the browser. const Jaysonic = require(\"jaysonic\"); const socket = require(\"jaysonic/lib/client-ws\"); // client and server with overrides // client in the browser const ws = new socket.wsclient({ url: \"ws://127.0.0.1:8100\" }); // or to work in node const ws = new Jaysonic.client.ws({ url: \"ws://127.0.0.1:8100\" }); const wss = new Jaysonic.server.ws({ port: 8100 }); Server side Instantiation and Listening const Jaysonic = require(\"jaysonic\"); const server = new Jaysonic.server.tcp(); server .listen() .then(({ host, port }) =&gt; { console.log(`Server listening on ${host}:${port}`); }) .catch((error) =&gt; { console.log(`Unable to start server, ${error}`); }); Closing the connection server .close() .then(() =&gt; { // do something }) .catch((error) =&gt; { // error when trying to close the connection }); Adding Methods server.method(\"add\", ([a, b]) =&gt; a + b); // can also add named const add = ([a, b]) =&gt; a + b; server.method(\"add\", add); // or promises const add = ([a, b]) =&gt; new Promise((resolve, reject) =&gt; { resolve(a + b); }); server.method(\"add\", add); Note: The same syntax for all the above methods is used for the HTTP and WS server Listening for client connections The clientConnected and clientDisconnected methods return the host and port of the client in the callback. These methods are not available for the HTTP server. server.clientConnected((event) =&gt; { console.log(\"client connected\"); }); server.clientDisconnected((event) =&gt; { console.log(\"client disconnected\"); }); Client Side Connecting const Jaysonic = require(\"jaysonic\"); const client = new Jaysonic.client.tcp(); client .connect() .then(({ host, port }) =&gt; { console.log(`Client connected on ${host}:${port}`); }) .catch((error) =&gt; { console.log(`Client unable to connect, ${error}`); }); Note that the HTTP client does not have a connect() method and can just begin making requests to the server. Listening for server disconnect The serverDisconnected method fires a callback when the server is disconnected. client.serverDisconnected(() =&gt; { // do something }); Ending the connection The TCP client accepts an optional callback function to .end() client.end(); // or client.end(() =&gt; console.log(\"connection ended\")); The websocket clients accept an optional status code and reason for closing per https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close client.end(1009, \"Message too big\"); Making requests Requests can only be made once connection is established. client .connect() .then(({ host, port }) =&gt; { add(); }) .catch((error) =&gt; { console.log(`Client unable to connect, ${error}`); }); const add = () =&gt; { client .send(\"add\", [1, 2]) .then((result) =&gt; { console.log(result); // {jsonrpc: \"2.0\", result: 3, id: 1} }) .catch((error) =&gt; { console.log(error); }); }; Subscriptions Clients can subscribe to notifications from the server. Note: Subscriptions are not supported by the HTTP server/client Notifications no longer return an error as the first parameter in the callback as of v2.0.0 client.subscribe(\"notification\", (message) =&gt; { console.log(message); // {jsonrpc: \"2.0\", method: \"notification\", params: []} }); server.notify([[\"notification\", []]]); The websocket browser client returns an object with a 'detail' key which contains the notification as of v2.0.0 wsclient.subscribe(\"notification\", ({ detail }) =&gt; { console.log(detail); // {jsonrpc: \"2.0\", method: \"notification\", params: []} }); wsserver.notify([[\"notification\", []]]); A client can also unsubscribe a method from a notification, or unsubscribe all methods from a notification. This requires the callback function to be named, else it wont be able to remove it. client.unsubscribe(\"notification\", callback); client.unsubscribeAll(\"notification\"); Batch Requests client .connect() .then(({ host, port }) =&gt; { add(); }) .catch((error) =&gt; { console.log(`Client unable to connect, ${error}`); }); const add = () =&gt; client .batch([ // access the message object on the request client.message(\"add\", [1, 2]), client.message(\"add\", [3, 4]) ]) .then((result) =&gt; { // [ // {jsonrpc: \"2.0\", result: 3, id: 1}, // {jsonrpc: \"2.0\", result: 7, id: 2} // ] }) .catch((error) =&gt; { console.log(error); }); The same syntax is used for the HTTP client HTTP Client Requests The HTTP Client will include additional information about the response, as per nodes http.IncomingMessage method. See more here. The HTTP client response and error are objects with a body property, which contains the json response from the server, as well as the http.IncomingMessage instance. Which contains things like the header and statusCode. All methods can be found here. Additionally, the error object contains a response property that provides the body of the erroneous response. client .send(\"add\", [1, 2]) .then((result) =&gt; { console.log(result.body); // 3 console.log(result.statusCode); // 200 }) .catch((error) =&gt; { console.log(error); }); Notifications Client Clients can send notifications to the server. The server can also listen for all notifications not tied to methods and handle accordingly. Note as of v2.0.0 server.onNotify no longer returns an error as the fist parameter to the callback // optionally returns a promise indicating success or failure for sending message client.notify(\"notify\", []); server.onNotify(\"notify\", (message) =&gt; { console.log(message); // {jsonrpc: \"2.0\", method: \"notify\", params: []} }); A server can also unsubscribe a method from a notification, or unsubscribe all methods from a notification. This requires the callback function to be named, else it wont be able to remove it. server.unsubscribeOnNotify(\"notification\", callback); server.unsubscribeAllOnNotify(\"notification\"); Server The server can send notifications to the client. This can be done individually or in a batch. Note: As of v2.0.0 notifications from the server are sent as a list of lists, instead of just supplying the method and params. This was done to handle batch notifications. server.notify will return a list of error objects if there was a problem sending the notification out to any client, or if no clients are connected. The error of one client will not affect the notification being sent out to the rest of the clients. // optionally returns a promise indicating success or failure for sending message client.subscribe(\"notify\", callback); // send a single notification server.notify([[\"notify\", []]]); // send a batch of notifications server.notify([ [\"notify\", []], [\"test\", [1, 2, 3]] ]); As of v2.0.0, notifications sent and recieved in batches are now supported Batches // send from the client by setting the 3rd parameter in the request().message() method to false client.batch([client.message(\"test\", [], false)]); // send from server by providing a list of arrays containing // a method and optional params value server.notify([[\"notification\", [\"a\", 1]], [\"browser\"]]); As per the JSON-RPC spec for HTTP, a notification response must include a 204 status code, with an empty response body. The HTTP Client will resolve a response object if it receives this response, and reject it otherwise. HTTP Client Notifications // optionally returns a promise indicating success or failure for sending message client .notify(\"notify\", []) .then((response) =&gt; { console.log(response.statusCode); // 204 }) .catch((error) =&gt; { console.log(error); }); server.onNotify(\"notify\", (message) =&gt; { console.log(message); // {jsonrpc: \"2.0\", method: \"notify\", params: []} }); Contributing Definitely welcome. I tried to account for everything in the spec, but issues come up of course. Keep it simple. Keep it minimal. Make sure all tests pass and no linting errors. Authors or Acknowledgments Isaac Rowell License This project is licensed under the MIT License × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"HttpClientFactory.html":{"id":"HttpClientFactory.html","title":"Class: HttpClientFactory","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: HttpClientFactory HttpClientFactory Creates instance of HttpClientFactory new HttpClientFactory(options) Additional parameters ontop of those inherited from JsonRpcClientFactory Parameters: Name Type Description options Object Connection options for the factory class Properties Name Type Argument Default Description encoding string &lt;optional&gt; \"utf-8\" Encoding to be used for the request method string &lt;optional&gt; \"POST\" Type of request to make headers object &lt;optional&gt; {\"Content-Type\": \"application/json\", Accept: \"application/json\"} Request headers path string &lt;optional&gt; \"/\" URL path to make request to Properties: Name Type Description headers object Same as options.headers encoding string Same as options.encoding Source: client/http.js, line 8 Extends JsonRpcClientFactory Methods batch(requests) Calls batch() method on protocol instance Parameters: Name Type Description requests Array.&lt;JSON&gt; Valid JSON-RPC batch request array Inherited From: JsonRpcClientFactory#batch Overrides: JsonRpcClientFactory#batch Source: client/index.js, line 119 cleanUp(ids) Clears pending timeouts kept in timeouts for the provided request IDs. Parameters: Name Type Description ids Array.&lt;string&gt; | Array.&lt;number&gt; Array of request IDs Inherited From: JsonRpcClientFactory#cleanUp Overrides: JsonRpcClientFactory#cleanUp Source: client/index.js, line 137 &lt;abstract&gt; connect() Calls connect() on protocol instance Inherited From: JsonRpcClientFactory#connect Overrides: JsonRpcClientFactory#connect Source: client/index.js, line 62 &lt;abstract&gt; end() Calls end() on protocol instance Inherited From: JsonRpcClientFactory#end Overrides: JsonRpcClientFactory#end Source: client/index.js, line 71 request() Calls request() method on protocol instance Inherited From: JsonRpcClientFactory#request Overrides: JsonRpcClientFactory#request Source: client/index.js, line 110 serverDisconnected(cb) Emits a serverDisconnected event, passing the callback function Parameters: Name Type Description cb function Inherited From: JsonRpcClientFactory#serverDisconnected Overrides: JsonRpcClientFactory#serverDisconnected Source: client/index.js, line 128 &lt;abstract&gt; subscribe(method, cb) Subscribe the function to the given event name Parameters: Name Type Description method string Method to subscribe to cb function Name of callback function to invoke on event Inherited From: JsonRpcClientFactory#subscribe Overrides: JsonRpcClientFactory#subscribe Source: client/index.js, line 82 &lt;abstract&gt; unsubscribe(method, cb) Unsubscribe the function from the given event name Parameters: Name Type Description method string Method to unsubscribe from cb function Name of function to remove Inherited From: JsonRpcClientFactory#unsubscribe Overrides: JsonRpcClientFactory#unsubscribe Source: client/index.js, line 93 &lt;abstract&gt; unsubscribeAll(method) Unsubscribe all functions from given event name Parameters: Name Type Description method string Method to unsubscribe all listeners from Inherited From: JsonRpcClientFactory#unsubscribeAll Overrides: JsonRpcClientFactory#unsubscribeAll Source: client/index.js, line 103 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"HttpClientProtocol.html":{"id":"HttpClientProtocol.html","title":"Class: HttpClientProtocol","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: HttpClientProtocol HttpClientProtocol Creates an instance of HttpClientProtocol, which has some tweaks from the base class required to work with the node.http package new HttpClientProtocol() Properties: Name Type Description headers object HTTP headers passed to the factory instance encoding string Encoding type passed to the factory instance Source: client/protocol/http.js, line 11 Requires: module:http Extends JsonRpcClientProtocol Requires module:http Methods batch(requests) Used to send a batch request to the server. Recommend using message to construct objects. Will use the IDs for the requests in the batch in an array as the keys for pendingCalls. How a client should associate batch responses is not in the spec, so this is the solution. Parameters: Name Type Description requests Array An array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#batch Overrides: JsonRpcClientProtocol#batch Source: client/protocol/base.js, line 370 Returns: Promise Example client.batch([client.message(\"foo\", [\"bar\"]), client.message(\"hello\", [], false)]) connect() Make the connection to the server. Calls setConnector to establish the node client connection. Calls listen if connection was successful, and will resolve the promise. Will retry connection on the connectionTimeout interval. Number of connection retries is based on remainingRetries Will reject the promise if connect or re-connect attempts fail. Inherited From: JsonRpcClientProtocol#connect Overrides: JsonRpcClientProtocol#connect Source: client/protocol/base.js, line 71 Returns: Promise end(cb) Ends connection to the server. Sets JsonRpcClientFactory.pcolInstance to undefined Parameters: Name Type Description cb function Called when connection is sucessfully closed Inherited From: JsonRpcClientProtocol#end Overrides: JsonRpcClientProtocol#end Source: client/protocol/base.js, line 108 getBatchResponse(batch) Returns the batch response. Overwrite if class needs to reformat in anyway (i.e. in HttpClientProtocol) Parameters: Name Type Description batch Array Array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#getBatchResponse Overrides: JsonRpcClientProtocol#getBatchResponse Source: client/protocol/base.js, line 429 getResponse(id) Get the outstanding request object for the given ID Parameters: Name Type Description id string | number ID of outstanding request Inherited From: JsonRpcClientProtocol#getResponse Overrides: JsonRpcClientProtocol#getResponse Source: client/protocol/base.js, line 247 gotBatch(message) Called when the received message is a batch Parameters: Name Type Description message Array.&lt;JSON&gt; A valid JSON-RPC batch message Inherited From: JsonRpcClientProtocol#gotBatch Overrides: JsonRpcClientProtocol#gotBatch Source: client/protocol/base.js, line 209 gotBatchResponse(batch) Associate the ids in the batch message to their corresponding pendingCalls. Will call _resolveOrRejectBatch when object is determined Parameters: Name Type Description batch Array Array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#gotBatchResponse Overrides: JsonRpcClientProtocol#gotBatchResponse Source: client/protocol/base.js, line 399 gotError(error) Calls rejectPendingCalls with error object. If the object cannot be parsed, then an unkown error code is sent with the error message Parameters: Name Type Description error string Stringified JSON-RPC error object Inherited From: JsonRpcClientProtocol#gotError Overrides: JsonRpcClientProtocol#gotError Source: client/protocol/base.js, line 527 gotNotification(message) Called when the received message is a notification. Emits an event using message.method as the name. The data passed to the event gotr is the message. Parameters: Name Type Description message JSON A valid JSON-RPC message object Inherited From: JsonRpcClientProtocol#gotNotification Overrides: JsonRpcClientProtocol#gotNotification Source: client/protocol/base.js, line 200 gotResponse(message) Called when the received message is a response object from the server Parameters: Name Type Description message JSON A valid JSON-RPC message object Inherited From: JsonRpcClientProtocol#gotResponse Overrides: JsonRpcClientProtocol#gotResponse Source: client/protocol/base.js, line 224 listen() Setup \"data\" event to listen for data coming into the client. Pushes received data into messageBuffer and calls _waitForData Inherited From: JsonRpcClientProtocol#listen Overrides: JsonRpcClientProtocol#listen Source: client/protocol/base.js, line 119 message(method, params [, id]) Generate a stringified JSON-RPC message object Parameters: Name Type Argument Default Description method string Name of the method to use in the request params Array | JSON Params to send id boolean &lt;optional&gt; true If true it will use instances message_id for the request id, if false will generate a notification request Inherited From: JsonRpcClientProtocol#message Overrides: JsonRpcClientProtocol#message Source: client/protocol/base.js, line 271 Example client.message(\"hello\", [\"world\"]) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"], \"id\": 1} client.message(\"hello\", [\"world\"], false) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"]} notify(method, params) Send a notification to the server. Promise will resolve if the request was sucessfully sent, and reject if there was an error sending the request. For the HttpClientProtocol, the resolved promise will return the http response object with a 204 response code per the spec. Parameters: Name Type Description method string Name of the method to use in the notification params Array | JSON Params to send Overrides: JsonRpcClientProtocol#notify Source: client/protocol/http.js, line 75 Returns: Promise Example client.notify(\"hello\", [\"world\"]) rejectPendingCalls(error) Reject the pending call for the given ID in the error object. If the error object has a null id, then log the message to the console. Parameters: Name Type Description error string Stringified JSON-RPC error object Inherited From: JsonRpcClientProtocol#rejectPendingCalls Overrides: JsonRpcClientProtocol#rejectPendingCalls Source: client/protocol/base.js, line 552 request() Method used to call message, notify and send Inherited From: JsonRpcClientProtocol#request Overrides: JsonRpcClientProtocol#request Source: client/protocol/base.js, line 348 Returns: Object Example client.request().send(\"hello\", [\"world\"]) client.request().notify(\"foo\") client.request().message(\"foo\", [\"bar\"]) send(method, params) Send a request to the server Promise will resolve when a response has been received for the request. Promise will reject if the server responds with an error object, or if the response is not received within the set requestTimeout Parameters: Name Type Description method string Name of the method to use in the request params Array | JSON Params to send Inherited From: JsonRpcClientProtocol#send Overrides: JsonRpcClientProtocol#send Source: client/protocol/base.js, line 325 Returns: Promise Example client.send(\"hello\", {\"foo\": \"bar\"}) &lt;abstract&gt; setConnector() Set the connector attribute for the protocol instance. The connector is essentially the socket instance for the client. Inherited From: JsonRpcClientProtocol#setConnector Overrides: JsonRpcClientProtocol#setConnector Source: client/protocol/base.js, line 51 verifyData(chunk) Verify the incoming data returned from messageBuffer Throw an error if its not a valid JSON-RPC object. Call gotNotification if the message a notification. Call gotBatch if the message is a batch request. Parameters: Name Type Description chunk string Inherited From: JsonRpcClientProtocol#verifyData Overrides: JsonRpcClientProtocol#verifyData Source: client/protocol/base.js, line 156 write(request [, cb]) Send a message to the server. Sets the request headers passed into headers Calls listen to start listening for recieved data from server. Ends connection when all data received from the server. Emits a serverDisconnected event when connection is closed. Throws an error if there was an error event received when sending the request Parameters: Name Type Argument Description request string Stringified JSON-RPC message object cb function &lt;optional&gt; Callback function to be called when message has been sent Overrides: JsonRpcClientProtocol#write Source: client/protocol/http.js, line 39 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"HttpServerFactory.html":{"id":"HttpServerFactory.html","title":"Class: HttpServerFactory","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: HttpServerFactory HttpServerFactory Creates instance of HttpServerFactory new HttpServerFactory() Source: server/http.js, line 10 Extends JsonRpcServerFactory Methods buildProtocol() Set the pcolInstance for the server factory Inherited From: JsonRpcServerFactory#buildProtocol Overrides: JsonRpcServerFactory#buildProtocol Source: server/index.js, line 78 Example this.pcolInstance = new JsonRpcClientProtocol() clientConnected(event) Called when clientConnected event is fired. Parameters: Name Type Description event object Returns host and port or error object Inherited From: JsonRpcServerFactory#clientConnected Source: server/index.js, line 275 clientDisconnected(event) Called when clientDisconnected event is fired. Parameters: Name Type Description event object Returns host and port or error object Inherited From: JsonRpcServerFactory#clientDisconnected Source: server/index.js, line 284 close() Close the server connection. Stops listening. Inherited From: JsonRpcServerFactory#close Source: server/index.js, line 139 Returns: Type Promise listen() Start listening for client connections to server. Inherited From: JsonRpcServerFactory#listen Source: server/index.js, line 51 Returns: Type Promise method(name, cb) Register a method and associated function with the server. The function will be called when a client makes a request to this method. Parameters: Name Type Description name string Name of method cb function Function to call when client makes request to method Inherited From: JsonRpcServerFactory#method Source: server/index.js, line 159 notify(notifications) Parameters: Name Type Description notifications Array.&lt;Array.&lt;string, (Array|object)&gt;&gt; Array of notifications Inherited From: JsonRpcServerFactory#notify Source: server/index.js, line 213 Returns: Returns list of error objects if there was an error sending to any client. Returns true if the entire data was sent successfully Returns false if all or part of the data was not sent to the client. Type Array.&lt;boolean&gt; | Array.&lt;Error&gt; Example server.notify([ [\"hello\", [\"world\"]], [\"foo\", {\"bar\": \"baz\"}] ]) onNotify(method, cb) Call function when notification with event name comes in. Parameters: Name Type Description method string Method name to listen for notification cb function Name of callback function fired when method event comes in Inherited From: JsonRpcServerFactory#onNotify Source: server/index.js, line 174 Example function world(){ return 'foo' } server.onNotify(\"hello\", world) removeAllOnNotify(method) Remove all functions listening for event name. Parameters: Name Type Description method string Method name to remove events for Inherited From: JsonRpcServerFactory#removeAllOnNotify Source: server/index.js, line 198 removeOnNotify(method, cb) Remove function name from listening for notifications. Parameters: Name Type Description method string Method name to remove cb function Name of the callback function to remove Inherited From: JsonRpcServerFactory#removeOnNotify Source: server/index.js, line 189 Example function world(){ return 'foo' } server.removeOnNotify(\"hello\", world) setServer() Set the server property for the server factory Inherited From: JsonRpcServerFactory#setServer Overrides: JsonRpcServerFactory#setServer Source: server/index.js, line 88 Example this.server = new net.Server() setupListeners() Setup the error and close events for the factory and server. Sets listening to false if any errors returned or if server stops listening. Calls the JsonRpcServerFactory and JsonRpcServerFactory methods Inherited From: JsonRpcServerFactory#setupListeners Source: server/index.js, line 100 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"HttpServerProtocol.html":{"id":"HttpServerProtocol.html","title":"Class: HttpServerProtocol","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: HttpServerProtocol HttpServerProtocol Creates instance of HttpServerProtocol new HttpServerProtocol() Properties: Name Type Description response class HTTP response object Source: server/protocol/http.js, line 8 Extends JsonRpcServerProtocol Methods clientConnected() Registers the event listener when client connects. Pushes received data into messageBuffer and calls _waitForData. Registers end event to emit a clientDisconnected event on the factory Inherited From: JsonRpcServerProtocol#clientConnected Overrides: JsonRpcServerProtocol#clientConnected Source: server/protocol/base.js, line 38 getResult(message) Get the result for the request. Calls the function associated with the method and returns the result. Parameters: Name Type Description message JSON Valid JSON-RPC message object Inherited From: JsonRpcServerProtocol#getResult Overrides: JsonRpcServerProtocol#getResult Source: server/protocol/base.js, line 249 Returns: Type Promise gotBatchRequest(requests) Attempts to get the result for all requests in the batch. Will send result to client if successful and error otherwise. Parameters: Name Type Description requests Array.&lt;JSON&gt; Valid JSON-RPC batch request Inherited From: JsonRpcServerProtocol#gotBatchRequest Overrides: JsonRpcServerProtocol#gotBatchRequest Source: server/protocol/base.js, line 225 Returns: Type Array.&lt;Promise&gt; gotError(error) Writes error to the client. Will send a JSON-RPC error object if the passed error cannot be parsed. Parameters: Name Type Description error string Stringified error object Inherited From: JsonRpcServerProtocol#gotError Overrides: JsonRpcServerProtocol#gotError Source: server/protocol/base.js, line 322 gotNotification(message) Calls emit on factory with the event name being message.method and the date being message. Responds to client. Parameters: Name Type Description message string Stringified JSON-RPC message object Overrides: JsonRpcServerProtocol#gotNotification Source: server/protocol/http.js, line 47 gotRequest(message) Attempts to get the result for the request object. Will send result to client if successful and will send an error otherwise. Parameters: Name Type Description message JSON JSON-RPC message object Inherited From: JsonRpcServerProtocol#gotRequest Overrides: JsonRpcServerProtocol#gotRequest Source: server/protocol/base.js, line 208 Returns: Type Promise validateMessage(message) Validates if there are any issues with the incoming request Parameters: Name Type Description message JSON Valid JSON-RPC request object Inherited From: JsonRpcServerProtocol#validateMessage Overrides: JsonRpcServerProtocol#validateMessage Source: server/protocol/base.js, line 147 Throws: Will throw an error for any of the below reasons Reason Type message is not an object Invalid Request the server does not have the required method Method Not Found the params are not an array or object Invalid Params the \"jsonrpc\" property was passed for a v1 server Invalid Request validateRequest(chunk) Validate the incoming data returned from messageBuffer Parameters: Name Type Description chunk string Inherited From: JsonRpcServerProtocol#validateRequest Overrides: JsonRpcServerProtocol#validateRequest Source: server/protocol/base.js, line 84 Throws: Will throw an error with a JSON-RPC error object if chunk cannot be parsed Returns: Type JSON writeToClient(message, notification) Send message to the client. If a notification is passed, then a 204 response code is sent. Parameters: Name Type Description message string Stringified JSON-RPC message object notification boolean Indicates if message is a notification Overrides: JsonRpcServerProtocol#writeToClient Source: server/protocol/http.js, line 26 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"Jaysonic.html":{"id":"Jaysonic.html","title":"Namespace: Jaysonic","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Namespace: Jaysonic Jaysonic Namespace available as require('jaysonic') Source: index.js, line 1 Members &lt;static&gt; client :JsonRpcClientFactory Type: JsonRpcClientFactory Source: index.js, line 11 &lt;static&gt; server :JsonRpcServerFactory Type: JsonRpcServerFactory Source: index.js, line 17 &lt;static&gt; wsclient :WsBrowserClientFactory Websocket Browser Client constructor Type: WsBrowserClientFactory Source: client-ws/index.js, line 8 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"JsonRpcClientFactory.html":{"id":"JsonRpcClientFactory.html","title":"Class: JsonRpcClientFactory","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: JsonRpcClientFactory JsonRpcClientFactory Creates an instance of JsonRpcClientFactory. This is the base factory which all other factories inherit from. new JsonRpcClientFactory(options) Parameters: Name Type Description options Object Connection options for the factory class Properties Name Type Argument Default Description host string &lt;optional&gt; \"127.0.0.1\" IP of server to connect to port number &lt;optional&gt; 8100 Port of server to connect to version number &lt;optional&gt; 2 JSON-RPC version to use (1|2) delimiter string &lt;optional&gt; \"\\n\" Delimiter to use for requests timeout number &lt;optional&gt; 30 Timeout for request response connectionTimeout number &lt;optional&gt; 5000 Timeout for connection to server retries number &lt;optional&gt; 2 Number of connection retry attempts Properties: Name Type Description pcolInstance class The JsonRpcClientProtocol instance timeouts object Key value pairs of request IDs to setTimeout instance requestTimeout number Same as options.timeout remainingRetries number Same as options.retries connectionTimeout number Same as options.connectionTimeout server object Object of host and port {host: options.host, port: options.port} Source: client/index.js, line 10 Requires: module:events Extends EventEmitter Requires module:events Members &lt;static&gt; http :HttpClientFactory HTTP client constructor Type: HttpClientFactory Source: client/index.js, line 156 &lt;static&gt; tcp :TcpClientFactory TCP client constructor Type: TcpClientFactory Source: client/index.js, line 149 &lt;static&gt; ws :WsClientFactory WebSocket client constructor Type: WsClientFactory Source: client/index.js, line 163 Methods batch(requests) Calls batch() method on protocol instance Parameters: Name Type Description requests Array.&lt;JSON&gt; Valid JSON-RPC batch request array Source: client/index.js, line 119 cleanUp(ids) Clears pending timeouts kept in timeouts for the provided request IDs. Parameters: Name Type Description ids Array.&lt;string&gt; | Array.&lt;number&gt; Array of request IDs Source: client/index.js, line 137 &lt;abstract&gt; connect() Calls connect() on protocol instance Source: client/index.js, line 62 &lt;abstract&gt; end() Calls end() on protocol instance Source: client/index.js, line 71 request() Calls request() method on protocol instance Source: client/index.js, line 110 serverDisconnected(cb) Emits a serverDisconnected event, passing the callback function Parameters: Name Type Description cb function Source: client/index.js, line 128 &lt;abstract&gt; subscribe(method, cb) Subscribe the function to the given event name Parameters: Name Type Description method string Method to subscribe to cb function Name of callback function to invoke on event Source: client/index.js, line 82 &lt;abstract&gt; unsubscribe(method, cb) Unsubscribe the function from the given event name Parameters: Name Type Description method string Method to unsubscribe from cb function Name of function to remove Source: client/index.js, line 93 &lt;abstract&gt; unsubscribeAll(method) Unsubscribe all functions from given event name Parameters: Name Type Description method string Method to unsubscribe all listeners from Source: client/index.js, line 103 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"JsonRpcClientProtocol.html":{"id":"JsonRpcClientProtocol.html","title":"Class: JsonRpcClientProtocol","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: JsonRpcClientProtocol JsonRpcClientProtocol Creates an instance of the base client protocol class. This is the class that all other client protocols inherit from. new JsonRpcClientProtocol(factory, version, delimiter) JsonRpcClientProtocol contructor Parameters: Name Type Description factory class Instance of JsonRpcClientFactory version string | number JSON-RPC version to use (1 or '2.0') delimiter string Delimiter to use for message buffer Properties: Name Type Description factory class Instance of JsonRpcClientFactory connector class The socket instance for the client version string | number JSON-RPC version to use (1 or '2.0') delimiter string Delimiter to use for message buffer message_id number Current message ID serving_message_id number Current message ID. Used for external functions to hook into pendingCalls Object Key value pairs for pending message IDs to promise resolve/reject objects responseQueue Object.&lt;(string|number), JSON&gt; Key value pairs for outstanding message IDs to response object server Object Server host and port object {host: \"x.x.x.x\", port: xxxx} messageBuffer class Instance of MessageBuffer Source: client/protocol/base.js, line 9 Methods batch(requests) Used to send a batch request to the server. Recommend using message to construct objects. Will use the IDs for the requests in the batch in an array as the keys for pendingCalls. How a client should associate batch responses is not in the spec, so this is the solution. Parameters: Name Type Description requests Array An array of valid JSON-RPC message objects Source: client/protocol/base.js, line 370 Returns: Promise Example client.batch([client.message(\"foo\", [\"bar\"]), client.message(\"hello\", [], false)]) connect() Make the connection to the server. Calls setConnector to establish the node client connection. Calls listen if connection was successful, and will resolve the promise. Will retry connection on the connectionTimeout interval. Number of connection retries is based on remainingRetries Will reject the promise if connect or re-connect attempts fail. Source: client/protocol/base.js, line 71 Returns: Promise end(cb) Ends connection to the server. Sets JsonRpcClientFactory.pcolInstance to undefined Parameters: Name Type Description cb function Called when connection is sucessfully closed Source: client/protocol/base.js, line 108 getBatchResponse(batch) Returns the batch response. Overwrite if class needs to reformat in anyway (i.e. in HttpClientProtocol) Parameters: Name Type Description batch Array Array of valid JSON-RPC message objects Source: client/protocol/base.js, line 429 getResponse(id) Get the outstanding request object for the given ID Parameters: Name Type Description id string | number ID of outstanding request Source: client/protocol/base.js, line 247 gotBatch(message) Called when the received message is a batch Parameters: Name Type Description message Array.&lt;JSON&gt; A valid JSON-RPC batch message Source: client/protocol/base.js, line 209 gotBatchResponse(batch) Associate the ids in the batch message to their corresponding pendingCalls. Will call _resolveOrRejectBatch when object is determined Parameters: Name Type Description batch Array Array of valid JSON-RPC message objects Source: client/protocol/base.js, line 399 gotError(error) Calls rejectPendingCalls with error object. If the object cannot be parsed, then an unkown error code is sent with the error message Parameters: Name Type Description error string Stringified JSON-RPC error object Source: client/protocol/base.js, line 527 gotNotification(message) Called when the received message is a notification. Emits an event using message.method as the name. The data passed to the event gotr is the message. Parameters: Name Type Description message JSON A valid JSON-RPC message object Source: client/protocol/base.js, line 200 gotResponse(message) Called when the received message is a response object from the server Parameters: Name Type Description message JSON A valid JSON-RPC message object Source: client/protocol/base.js, line 224 listen() Setup \"data\" event to listen for data coming into the client. Pushes received data into messageBuffer and calls _waitForData Source: client/protocol/base.js, line 119 message(method, params [, id]) Generate a stringified JSON-RPC message object Parameters: Name Type Argument Default Description method string Name of the method to use in the request params Array | JSON Params to send id boolean &lt;optional&gt; true If true it will use instances message_id for the request id, if false will generate a notification request Source: client/protocol/base.js, line 271 Example client.message(\"hello\", [\"world\"]) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"], \"id\": 1} client.message(\"hello\", [\"world\"], false) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"]} notify(method, params) Send a notification to the server. Promise will resolve if the request was sucessfully sent, and reject if there was an error sending the request. Parameters: Name Type Description method string Name of the method to use in the notification params Array | JSON Params to send Source: client/protocol/base.js, line 297 Returns: Promise Example client.notify(\"hello\", [\"world\"]) rejectPendingCalls(error) Reject the pending call for the given ID in the error object. If the error object has a null id, then log the message to the console. Parameters: Name Type Description error string Stringified JSON-RPC error object Source: client/protocol/base.js, line 552 request() Method used to call message, notify and send Source: client/protocol/base.js, line 348 Returns: Object Example client.request().send(\"hello\", [\"world\"]) client.request().notify(\"foo\") client.request().message(\"foo\", [\"bar\"]) send(method, params) Send a request to the server Promise will resolve when a response has been received for the request. Promise will reject if the server responds with an error object, or if the response is not received within the set requestTimeout Parameters: Name Type Description method string Name of the method to use in the request params Array | JSON Params to send Source: client/protocol/base.js, line 325 Returns: Promise Example client.send(\"hello\", {\"foo\": \"bar\"}) &lt;abstract&gt; setConnector() Set the connector attribute for the protocol instance. The connector is essentially the socket instance for the client. Source: client/protocol/base.js, line 51 verifyData(chunk) Verify the incoming data returned from messageBuffer Throw an error if its not a valid JSON-RPC object. Call gotNotification if the message a notification. Call gotBatch if the message is a batch request. Parameters: Name Type Description chunk string Source: client/protocol/base.js, line 156 write(request [, cb]) Send a message to the server Parameters: Name Type Argument Description request string Stringified JSON-RPC message object cb function &lt;optional&gt; Callback function to be called when message has been sent Source: client/protocol/base.js, line 257 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"JsonRpcServerFactory.html":{"id":"JsonRpcServerFactory.html","title":"Class: JsonRpcServerFactory","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: JsonRpcServerFactory JsonRpcServerFactory Creates an instance of JsonRpcServerFactory new JsonRpcServerFactory(options) Parameters: Name Type Description options object Properties Name Type Argument Default Description host Object &lt;optional&gt; Host IP to open server with port Object &lt;optional&gt; Host port to open server with version Number &lt;optional&gt; 2 JSON-RPC version to use (1|2) delimiter String &lt;optional&gt; \"\\n\" Delimiter to use for JsonRpcServerProtocol exlusive Boolean &lt;optional&gt; false disallow port sharing Properties: Name Type Description methods object Key value pairs of server method to function call connectedClients array List of connected clients listening boolean Inidicates if the server is currently listening pcolInstance class Instance of JsonRpcServerProtocol Source: server/index.js, line 8 Extends events Members &lt;static&gt; http :HttpServerFactory HTTP server constructor Type: HttpServerFactory Source: server/index.js, line 296 &lt;static&gt; tcp :TcpServerFactory TCP server constructor Type: TcpServerFactory Source: server/index.js, line 303 &lt;static&gt; ws :WsServerFactory WS server constructor Type: WsServerFactory Source: server/index.js, line 310 Methods &lt;abstract&gt; buildProtocol() Set the pcolInstance for the server factory Source: server/index.js, line 78 Example this.pcolInstance = new JsonRpcClientProtocol() clientConnected(event) Called when clientConnected event is fired. Parameters: Name Type Description event object Returns host and port or error object Source: server/index.js, line 275 clientDisconnected(event) Called when clientDisconnected event is fired. Parameters: Name Type Description event object Returns host and port or error object Source: server/index.js, line 284 close() Close the server connection. Stops listening. Source: server/index.js, line 139 Returns: Type Promise listen() Start listening for client connections to server. Source: server/index.js, line 51 Returns: Type Promise method(name, cb) Register a method and associated function with the server. The function will be called when a client makes a request to this method. Parameters: Name Type Description name string Name of method cb function Function to call when client makes request to method Source: server/index.js, line 159 notify(notifications) Parameters: Name Type Description notifications Array.&lt;Array.&lt;string, (Array|object)&gt;&gt; Array of notifications Source: server/index.js, line 213 Returns: Returns list of error objects if there was an error sending to any client. Returns true if the entire data was sent successfully Returns false if all or part of the data was not sent to the client. Type Array.&lt;boolean&gt; | Array.&lt;Error&gt; Example server.notify([ [\"hello\", [\"world\"]], [\"foo\", {\"bar\": \"baz\"}] ]) onNotify(method, cb) Call function when notification with event name comes in. Parameters: Name Type Description method string Method name to listen for notification cb function Name of callback function fired when method event comes in Source: server/index.js, line 174 Example function world(){ return 'foo' } server.onNotify(\"hello\", world) removeAllOnNotify(method) Remove all functions listening for event name. Parameters: Name Type Description method string Method name to remove events for Source: server/index.js, line 198 removeOnNotify(method, cb) Remove function name from listening for notifications. Parameters: Name Type Description method string Method name to remove cb function Name of the callback function to remove Source: server/index.js, line 189 Example function world(){ return 'foo' } server.removeOnNotify(\"hello\", world) &lt;abstract&gt; setServer() Set the server property for the server factory Source: server/index.js, line 88 Example this.server = new net.Server() setupListeners() Setup the error and close events for the factory and server. Sets listening to false if any errors returned or if server stops listening. Calls the JsonRpcServerFactory and JsonRpcServerFactory methods Source: server/index.js, line 100 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"JsonRpcServerProtocol.html":{"id":"JsonRpcServerProtocol.html","title":"Class: JsonRpcServerProtocol","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: JsonRpcServerProtocol JsonRpcServerProtocol Creates an instance of JsonRpcServerProtocol. This is the base protocol from which all others inherit. new JsonRpcServerProtocol(factory, client, version, delimiter) Parameters: Name Type Description factory class Instance of JsonRpcServerFactory client class Instance of net.Socket version string | number JSON-RPC version to use delimiter string Delimiter to use for messageBuffer Properties: Name Type Default Description messageBuffer class Instance of MessageBuffer event string \"data\" The event name to listen for incoming data Source: server/protocol/base.js, line 10 Methods clientConnected() Registers the event listener when client connects. Pushes received data into messageBuffer and calls _waitForData. Registers end event to emit a clientDisconnected event on the factory Source: server/protocol/base.js, line 38 getResult(message) Get the result for the request. Calls the function associated with the method and returns the result. Parameters: Name Type Description message JSON Valid JSON-RPC message object Source: server/protocol/base.js, line 249 Returns: Type Promise gotBatchRequest(requests) Attempts to get the result for all requests in the batch. Will send result to client if successful and error otherwise. Parameters: Name Type Description requests Array.&lt;JSON&gt; Valid JSON-RPC batch request Source: server/protocol/base.js, line 225 Returns: Type Array.&lt;Promise&gt; gotError(error) Writes error to the client. Will send a JSON-RPC error object if the passed error cannot be parsed. Parameters: Name Type Description error string Stringified error object Source: server/protocol/base.js, line 322 gotNotification(message) Calls emit on factory with the event name being message.method and the date being message. Parameters: Name Type Description message string Stringified JSON-RPC message object Source: server/protocol/base.js, line 196 gotRequest(message) Attempts to get the result for the request object. Will send result to client if successful and will send an error otherwise. Parameters: Name Type Description message JSON JSON-RPC message object Source: server/protocol/base.js, line 208 Returns: Type Promise validateMessage(message) Validates if there are any issues with the incoming request Parameters: Name Type Description message JSON Valid JSON-RPC request object Source: server/protocol/base.js, line 147 Throws: Will throw an error for any of the below reasons Reason Type message is not an object Invalid Request the server does not have the required method Method Not Found the params are not an array or object Invalid Params the \"jsonrpc\" property was passed for a v1 server Invalid Request validateRequest(chunk) Validate the incoming data returned from messageBuffer Parameters: Name Type Description chunk string Source: server/protocol/base.js, line 84 Throws: Will throw an error with a JSON-RPC error object if chunk cannot be parsed Returns: Type JSON writeToClient(message) Send message to the client Parameters: Name Type Description message string Stringified JSON-RPC message object Source: server/protocol/base.js, line 186 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"MessageBuffer.html":{"id":"MessageBuffer.html","title":"Class: MessageBuffer","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: MessageBuffer MessageBuffer Creates an instance of MessageBuffer. The buffer accumulates received data and returns true or false for when a delimiter has been recieved. If a delimiter is recieved into the buffer, the message up to that point can be removed from the buffer and returned. new MessageBuffer(delimiter) Parameters: Name Type Description delimiter string The delimiter to use to determine if a message is complete Source: util/buffer.js, line 16 Example // We can receive whole messages or parital, so we need to buffer {\"jsonrpc\": 2.0, \"params\": [\"hello\"], id: 1}\\n // whole message // or {\"jsonrpc\": 2.0, \"params\" // partial message Methods getMessage() Return the message from the buffer if delimiter is found, and null otherwise. The message is everything before the delimiter. Replace message string in buffer with empty string. Source: util/buffer.js, line 74 Returns: message Type string | null Example const message = messageBuffer.getMessage() console.log(message) // \"hello\" handleData() Source: util/buffer.js, line 87 Returns: MessageBuffer.getMessage() Type function isFinished() Used to determine if the buffer is empty. Buffer is considered empty if its an empty string or contains no delimiter Source: util/buffer.js, line 37 Returns: Type boolean Example while(!messageBuffer.isFinished()){ // get current data and verify } push(data) Accumulate the buffer with messages. If the server isnt sending delimiters for some reason then nothing will ever come back for these requests. Parameters: Name Type Description data string Data to push into buffer Source: util/buffer.js, line 57 Example messageBuffer.push(\"hello\\n\") × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"TcpClientFactory.html":{"id":"TcpClientFactory.html","title":"Class: TcpClientFactory","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: TcpClientFactory TcpClientFactory Creates instance of TcpClientFactory new TcpClientFactory() Source: client/tcp.js, line 9 Extends JsonRpcClientFactory Methods batch(requests) Calls batch() method on protocol instance Parameters: Name Type Description requests Array.&lt;JSON&gt; Valid JSON-RPC batch request array Inherited From: JsonRpcClientFactory#batch Source: client/index.js, line 119 cleanUp(ids) Clears pending timeouts kept in timeouts for the provided request IDs. Parameters: Name Type Description ids Array.&lt;string&gt; | Array.&lt;number&gt; Array of request IDs Inherited From: JsonRpcClientFactory#cleanUp Source: client/index.js, line 137 connect() Calls connect() on protocol instance Inherited From: JsonRpcClientFactory#connect Overrides: JsonRpcClientFactory#connect Source: client/index.js, line 62 end() Calls end() on protocol instance Inherited From: JsonRpcClientFactory#end Overrides: JsonRpcClientFactory#end Source: client/index.js, line 71 request() Calls request() method on protocol instance Inherited From: JsonRpcClientFactory#request Source: client/index.js, line 110 serverDisconnected(cb) Emits a serverDisconnected event, passing the callback function Parameters: Name Type Description cb function Inherited From: JsonRpcClientFactory#serverDisconnected Source: client/index.js, line 128 subscribe(method, cb) Subscribe the function to the given event name Parameters: Name Type Description method string Method to subscribe to cb function Name of callback function to invoke on event Inherited From: JsonRpcClientFactory#subscribe Overrides: JsonRpcClientFactory#subscribe Source: client/index.js, line 82 unsubscribe(method, cb) Unsubscribe the function from the given event name Parameters: Name Type Description method string Method to unsubscribe from cb function Name of function to remove Inherited From: JsonRpcClientFactory#unsubscribe Overrides: JsonRpcClientFactory#unsubscribe Source: client/index.js, line 93 unsubscribeAll(method) Unsubscribe all functions from given event name Parameters: Name Type Description method string Method to unsubscribe all listeners from Inherited From: JsonRpcClientFactory#unsubscribeAll Overrides: JsonRpcClientFactory#unsubscribeAll Source: client/index.js, line 103 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"TcpClientProtocol.html":{"id":"TcpClientProtocol.html","title":"Class: TcpClientProtocol","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: TcpClientProtocol TcpClientProtocol Creates an instance of TcpClientProtocol new TcpClientProtocol() Source: client/protocol/tcp.js, line 10 Requires: module:net Extends JsonRpcClientProtocol Requires module:net Methods batch(requests) Used to send a batch request to the server. Recommend using message to construct objects. Will use the IDs for the requests in the batch in an array as the keys for pendingCalls. How a client should associate batch responses is not in the spec, so this is the solution. Parameters: Name Type Description requests Array An array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#batch Source: client/protocol/base.js, line 370 Returns: Promise Example client.batch([client.message(\"foo\", [\"bar\"]), client.message(\"hello\", [], false)]) connect() Make the connection to the server. Calls setConnector to establish the node client connection. Calls listen if connection was successful, and will resolve the promise. Will retry connection on the connectionTimeout interval. Number of connection retries is based on remainingRetries Will reject the promise if connect or re-connect attempts fail. Inherited From: JsonRpcClientProtocol#connect Source: client/protocol/base.js, line 71 Returns: Promise end(cb) Ends connection to the server. Sets JsonRpcClientFactory.pcolInstance to undefined Parameters: Name Type Description cb function Called when connection is sucessfully closed Inherited From: JsonRpcClientProtocol#end Source: client/protocol/base.js, line 108 getBatchResponse(batch) Returns the batch response. Overwrite if class needs to reformat in anyway (i.e. in HttpClientProtocol) Parameters: Name Type Description batch Array Array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#getBatchResponse Source: client/protocol/base.js, line 429 getResponse(id) Get the outstanding request object for the given ID Parameters: Name Type Description id string | number ID of outstanding request Inherited From: JsonRpcClientProtocol#getResponse Source: client/protocol/base.js, line 247 gotBatch(message) Called when the received message is a batch Parameters: Name Type Description message Array.&lt;JSON&gt; A valid JSON-RPC batch message Inherited From: JsonRpcClientProtocol#gotBatch Source: client/protocol/base.js, line 209 gotBatchResponse(batch) Associate the ids in the batch message to their corresponding pendingCalls. Will call _resolveOrRejectBatch when object is determined Parameters: Name Type Description batch Array Array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#gotBatchResponse Source: client/protocol/base.js, line 399 gotError(error) Calls rejectPendingCalls with error object. If the object cannot be parsed, then an unkown error code is sent with the error message Parameters: Name Type Description error string Stringified JSON-RPC error object Inherited From: JsonRpcClientProtocol#gotError Source: client/protocol/base.js, line 527 gotNotification(message) Called when the received message is a notification. Emits an event using message.method as the name. The data passed to the event gotr is the message. Parameters: Name Type Description message JSON A valid JSON-RPC message object Inherited From: JsonRpcClientProtocol#gotNotification Source: client/protocol/base.js, line 200 gotResponse(message) Called when the received message is a response object from the server Parameters: Name Type Description message JSON A valid JSON-RPC message object Inherited From: JsonRpcClientProtocol#gotResponse Source: client/protocol/base.js, line 224 listen() Setup \"data\" event to listen for data coming into the client. Pushes received data into messageBuffer and calls _waitForData Inherited From: JsonRpcClientProtocol#listen Source: client/protocol/base.js, line 119 message(method, params [, id]) Generate a stringified JSON-RPC message object Parameters: Name Type Argument Default Description method string Name of the method to use in the request params Array | JSON Params to send id boolean &lt;optional&gt; true If true it will use instances message_id for the request id, if false will generate a notification request Inherited From: JsonRpcClientProtocol#message Source: client/protocol/base.js, line 271 Example client.message(\"hello\", [\"world\"]) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"], \"id\": 1} client.message(\"hello\", [\"world\"], false) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"]} notify(method, params) Send a notification to the server. Promise will resolve if the request was sucessfully sent, and reject if there was an error sending the request. Parameters: Name Type Description method string Name of the method to use in the notification params Array | JSON Params to send Inherited From: JsonRpcClientProtocol#notify Source: client/protocol/base.js, line 297 Returns: Promise Example client.notify(\"hello\", [\"world\"]) rejectPendingCalls(error) Reject the pending call for the given ID in the error object. If the error object has a null id, then log the message to the console. Parameters: Name Type Description error string Stringified JSON-RPC error object Inherited From: JsonRpcClientProtocol#rejectPendingCalls Source: client/protocol/base.js, line 552 request() Method used to call message, notify and send Inherited From: JsonRpcClientProtocol#request Source: client/protocol/base.js, line 348 Returns: Object Example client.request().send(\"hello\", [\"world\"]) client.request().notify(\"foo\") client.request().message(\"foo\", [\"bar\"]) send(method, params) Send a request to the server Promise will resolve when a response has been received for the request. Promise will reject if the server responds with an error object, or if the response is not received within the set requestTimeout Parameters: Name Type Description method string Name of the method to use in the request params Array | JSON Params to send Inherited From: JsonRpcClientProtocol#send Source: client/protocol/base.js, line 325 Returns: Promise Example client.send(\"hello\", {\"foo\": \"bar\"}) setConnector() Set the connector attribute for the JsonRpcClientProtocol instance. The connector is essentially the socket instance for the client. For the TcpClientProtocol this is net.Socket() Overrides: JsonRpcClientProtocol#setConnector Source: client/protocol/tcp.js, line 17 verifyData(chunk) Verify the incoming data returned from messageBuffer Throw an error if its not a valid JSON-RPC object. Call gotNotification if the message a notification. Call gotBatch if the message is a batch request. Parameters: Name Type Description chunk string Inherited From: JsonRpcClientProtocol#verifyData Source: client/protocol/base.js, line 156 write(request [, cb]) Send a message to the server Parameters: Name Type Argument Description request string Stringified JSON-RPC message object cb function &lt;optional&gt; Callback function to be called when message has been sent Inherited From: JsonRpcClientProtocol#write Source: client/protocol/base.js, line 257 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"TcpServerFactory.html":{"id":"TcpServerFactory.html","title":"Class: TcpServerFactory","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: TcpServerFactory TcpServerFactory Creates an instance of TcpServerFactory new TcpServerFactory() Source: server/tcp.js, line 9 Extends JsonRpcServerFactory Methods buildProtocol() Set the pcolInstance for the server factory Inherited From: JsonRpcServerFactory#buildProtocol Overrides: JsonRpcServerFactory#buildProtocol Source: server/index.js, line 78 Example this.pcolInstance = new JsonRpcClientProtocol() clientConnected(event) Called when clientConnected event is fired. Parameters: Name Type Description event object Returns host and port or error object Inherited From: JsonRpcServerFactory#clientConnected Source: server/index.js, line 275 clientDisconnected(event) Called when clientDisconnected event is fired. Parameters: Name Type Description event object Returns host and port or error object Inherited From: JsonRpcServerFactory#clientDisconnected Source: server/index.js, line 284 close() Close the server connection. Stops listening. Inherited From: JsonRpcServerFactory#close Source: server/index.js, line 139 Returns: Type Promise listen() Start listening for client connections to server. Inherited From: JsonRpcServerFactory#listen Source: server/index.js, line 51 Returns: Type Promise method(name, cb) Register a method and associated function with the server. The function will be called when a client makes a request to this method. Parameters: Name Type Description name string Name of method cb function Function to call when client makes request to method Inherited From: JsonRpcServerFactory#method Source: server/index.js, line 159 notify(notifications) Parameters: Name Type Description notifications Array.&lt;Array.&lt;string, (Array|object)&gt;&gt; Array of notifications Inherited From: JsonRpcServerFactory#notify Source: server/index.js, line 213 Returns: Returns list of error objects if there was an error sending to any client. Returns true if the entire data was sent successfully Returns false if all or part of the data was not sent to the client. Type Array.&lt;boolean&gt; | Array.&lt;Error&gt; Example server.notify([ [\"hello\", [\"world\"]], [\"foo\", {\"bar\": \"baz\"}] ]) onNotify(method, cb) Call function when notification with event name comes in. Parameters: Name Type Description method string Method name to listen for notification cb function Name of callback function fired when method event comes in Inherited From: JsonRpcServerFactory#onNotify Source: server/index.js, line 174 Example function world(){ return 'foo' } server.onNotify(\"hello\", world) removeAllOnNotify(method) Remove all functions listening for event name. Parameters: Name Type Description method string Method name to remove events for Inherited From: JsonRpcServerFactory#removeAllOnNotify Source: server/index.js, line 198 removeOnNotify(method, cb) Remove function name from listening for notifications. Parameters: Name Type Description method string Method name to remove cb function Name of the callback function to remove Inherited From: JsonRpcServerFactory#removeOnNotify Source: server/index.js, line 189 Example function world(){ return 'foo' } server.removeOnNotify(\"hello\", world) sendNotification(client, response) Send notification to client Parameters: Name Type Description client class Client instance response string Stringified JSON-RPC message to sent to client Source: server/tcp.js, line 37 Throws: Will throw an error if client is not defined setServer() Set the server property for the server factory Inherited From: JsonRpcServerFactory#setServer Overrides: JsonRpcServerFactory#setServer Source: server/index.js, line 88 Example this.server = new net.Server() setupListeners() Setup the error and close events for the factory and server. Sets listening to false if any errors returned or if server stops listening. Calls the JsonRpcServerFactory and JsonRpcServerFactory methods Inherited From: JsonRpcServerFactory#setupListeners Source: server/index.js, line 100 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"TcpServerProtocol.html":{"id":"TcpServerProtocol.html","title":"Class: TcpServerProtocol","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: TcpServerProtocol TcpServerProtocol Creates instance of TcpServerProtocol new TcpServerProtocol() Source: server/protocol/tcp.js, line 7 Extends JsonRpcServerProtocol Methods clientConnected() Registers the event listener when client connects. Pushes received data into messageBuffer and calls _waitForData. Registers end event to emit a clientDisconnected event on the factory Inherited From: JsonRpcServerProtocol#clientConnected Source: server/protocol/base.js, line 38 getResult(message) Get the result for the request. Calls the function associated with the method and returns the result. Parameters: Name Type Description message JSON Valid JSON-RPC message object Inherited From: JsonRpcServerProtocol#getResult Source: server/protocol/base.js, line 249 Returns: Type Promise gotBatchRequest(requests) Attempts to get the result for all requests in the batch. Will send result to client if successful and error otherwise. Parameters: Name Type Description requests Array.&lt;JSON&gt; Valid JSON-RPC batch request Inherited From: JsonRpcServerProtocol#gotBatchRequest Source: server/protocol/base.js, line 225 Returns: Type Array.&lt;Promise&gt; gotError(error) Writes error to the client. Will send a JSON-RPC error object if the passed error cannot be parsed. Parameters: Name Type Description error string Stringified error object Inherited From: JsonRpcServerProtocol#gotError Source: server/protocol/base.js, line 322 gotNotification(message) Calls emit on factory with the event name being message.method and the date being message. Parameters: Name Type Description message string Stringified JSON-RPC message object Inherited From: JsonRpcServerProtocol#gotNotification Source: server/protocol/base.js, line 196 gotRequest(message) Attempts to get the result for the request object. Will send result to client if successful and will send an error otherwise. Parameters: Name Type Description message JSON JSON-RPC message object Inherited From: JsonRpcServerProtocol#gotRequest Source: server/protocol/base.js, line 208 Returns: Type Promise validateMessage(message) Validates if there are any issues with the incoming request Parameters: Name Type Description message JSON Valid JSON-RPC request object Inherited From: JsonRpcServerProtocol#validateMessage Source: server/protocol/base.js, line 147 Throws: Will throw an error for any of the below reasons Reason Type message is not an object Invalid Request the server does not have the required method Method Not Found the params are not an array or object Invalid Params the \"jsonrpc\" property was passed for a v1 server Invalid Request validateRequest(chunk) Validate the incoming data returned from messageBuffer Parameters: Name Type Description chunk string Inherited From: JsonRpcServerProtocol#validateRequest Source: server/protocol/base.js, line 84 Throws: Will throw an error with a JSON-RPC error object if chunk cannot be parsed Returns: Type JSON writeToClient(message) Send message to the client Parameters: Name Type Description message string Stringified JSON-RPC message object Inherited From: JsonRpcServerProtocol#writeToClient Source: server/protocol/base.js, line 186 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"Utils.html":{"id":"Utils.html","title":"Namespace: Utils","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Namespace: Utils Utils Source: util/index.js, line 1 Namespaces constants format Members &lt;static&gt; MessageBuffer :MessageBuffer Type: MessageBuffer Source: util/index.js, line 11 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"Utils.constants.html":{"id":"Utils.constants.html","title":"Namespace: constants","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Namespace: constants Utils. constants Source: util/index.js, line 22 Members &lt;static, constant&gt; ERR_CODES Properties: Name Type Description ERR_CODES object Properties Name Type Description parseError number 32700 invalidRequest number 32600 methodNotFound number 32601 invalidParams number 32602 internal number 32603 timeout number 32000 unknown number 32001 Source: util/constants.js, line 13 &lt;static, constant&gt; ERR_MSGS Properties: Name Type Description ERR_MSGS object ERR_CODES.parseError string \"Parse Error\" ERR_CODES.invalidRequest string \"Invalid Request\" ERR_CODES.methodNotFound string \"Method not found\" ERR_CODES.invalidParams string \"Invalid Parameters\" ERR_CODES.internal string \"Internal Error\" ERR_CODES.timeout string \"Request Timeout\" ERR_CODES.unknown string \"Unknown Error\" Source: util/constants.js, line 34 &lt;static, constant&gt; errorToStatus Returns HTTP status code for a given error code Properties: Name Type Description errorToStatus object Properties Name Type Description -32700 number 500 -32600 number 400 -32601 number 404 -32602 number 500 -32603 number 500 -32000 number 408 -32001 number 500 Source: util/constants.js, line 56 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"Utils.format.html":{"id":"Utils.format.html","title":"Namespace: format","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Namespace: format Utils. format Generate a valid JSON-RPC request, response or error object with an appended delimiter. Source: util/index.js, line 13 Methods &lt;static&gt; formatError(error) Generates a stringified JSON-RPC error object with appended delimiter. Parameters: Name Type Description error object Properties Name Type Description message string code array | object id string | number jsonrpc string | number delimiter string data string | object | array Source: util/format.js, line 110 &lt;static&gt; formatRequest(request) Generates a stringified JSON-RPC request object with appended delimiter. Parameters: Name Type Description request object Properties Name Type Description method string params array | object id string | number version string | number delimiter string Source: util/format.js, line 1 &lt;static&gt; formatResponse(response) Generates a stringified JSON-RPC response object with appended delimiter. Parameters: Name Type Description response object Properties Name Type Description method string params array | object id string | number jsonrpc string | number delimiter string result Source: util/format.js, line 46 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"WsBrowserClientFactory.html":{"id":"WsBrowserClientFactory.html","title":"Class: WsBrowserClientFactory","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: WsBrowserClientFactory WsBrowserClientFactory Creates an instance of WsBrowserClientFactory. For websocket client use in the browser. new WsBrowserClientFactory(options) Parameters: Name Type Description options Object Connection options for the factory class Properties Name Type Argument Default Description url string &lt;optional&gt; \"ws://127.0.0.1:8100\" IP of server to connect to version number &lt;optional&gt; 2 JSON-RPC version to use (1|2) delimiter string &lt;optional&gt; \"\\n\" Delimiter to use for requests timeout number &lt;optional&gt; 30 Timeout for request response connectionTimeout number &lt;optional&gt; 5000 Timeout for connection to server retries number &lt;optional&gt; 2 Number of connection retry attempts Properties: Name Type Description pcolInstance class The JsonRpcClientProtocol instance timeouts object Key value pairs of request IDs to setTimeout instance requestTimeout number Same as options.timeout remainingRetries number Same as options.retries connectionTimeout number Same as options.connectionTimeout url string Same as options.url Source: client-ws/ws.js, line 11 Extends EventTarget Methods batch(requests) Calls batch() method on protocol instance Parameters: Name Type Description requests Array.&lt;JSON&gt; Valid JSON-RPC batch request array Source: client-ws/ws.js, line 94 cleanUp(ids) Clears pending timeouts kept in timeouts for the provided request IDs. Parameters: Name Type Description ids Array.&lt;string&gt; | Array.&lt;number&gt; Array of request IDs Source: client-ws/ws.js, line 103 connect() Calls connect() on protocol instance Source: client-ws/ws.js, line 61 end() Calls end() on protocol instance Source: client-ws/ws.js, line 78 request() Calls request() method on protocol instance Source: client-ws/ws.js, line 85 &lt;abstract&gt; subscribe(method, cb) Subscribe the function to the given event name Parameters: Name Type Description method string Method to subscribe to cb function Name of callback function to invoke on event Source: client-ws/ws.js, line 116 &lt;abstract&gt; unsubscribe(method, cb) Unsubscribe the function from the given event name Parameters: Name Type Description method string Method to unsubscribe from cb function Name of function to remove Source: client-ws/ws.js, line 135 &lt;abstract&gt; unsubscribeAll(method) Unsubscribe all functions from given event name Parameters: Name Type Description method string Method to unsubscribe all listeners from Source: client-ws/ws.js, line 154 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"WsBrowserClientProtocol.html":{"id":"WsBrowserClientProtocol.html","title":"Class: WsBrowserClientProtocol","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: WsBrowserClientProtocol WsBrowserClientProtocol Creates an instance of WsBrowserClientProtocol new WsBrowserClientProtocol() Source: client/protocol/ws-browser.js, line 8 Extends WsClientProtocol Methods batch(requests) Used to send a batch request to the server. Recommend using message to construct objects. Will use the IDs for the requests in the batch in an array as the keys for pendingCalls. How a client should associate batch responses is not in the spec, so this is the solution. Parameters: Name Type Description requests Array An array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#batch Source: client/protocol/base.js, line 370 Returns: Promise Example client.batch([client.message(\"foo\", [\"bar\"]), client.message(\"hello\", [], false)]) getBatchResponse(batch) Returns the batch response. Overwrite if class needs to reformat in anyway (i.e. in HttpClientProtocol) Parameters: Name Type Description batch Array Array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#getBatchResponse Source: client/protocol/base.js, line 429 getResponse(id) Get the outstanding request object for the given ID Parameters: Name Type Description id string | number ID of outstanding request Inherited From: JsonRpcClientProtocol#getResponse Source: client/protocol/base.js, line 247 gotBatch(message) Called when the received message is a batch Parameters: Name Type Description message Array.&lt;JSON&gt; A valid JSON-RPC batch message Inherited From: JsonRpcClientProtocol#gotBatch Overrides: WsClientProtocol#gotBatch Source: client/protocol/base.js, line 209 gotBatchResponse(batch) Associate the ids in the batch message to their corresponding pendingCalls. Will call _resolveOrRejectBatch when object is determined Parameters: Name Type Description batch Array Array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#gotBatchResponse Source: client/protocol/base.js, line 399 gotError(error) Calls rejectPendingCalls with error object. If the object cannot be parsed, then an unkown error code is sent with the error message Parameters: Name Type Description error string Stringified JSON-RPC error object Inherited From: JsonRpcClientProtocol#gotError Source: client/protocol/base.js, line 527 gotNotification(message) Called when the received message is a notification. Emits an event using message.method as the name. The data passed to the event gotr is the message. Parameters: Name Type Description message JSON A valid JSON-RPC message object Inherited From: JsonRpcClientProtocol#gotNotification Overrides: WsClientProtocol#gotNotification Source: client/protocol/base.js, line 200 gotResponse(message) Called when the received message is a response object from the server Parameters: Name Type Description message JSON A valid JSON-RPC message object Inherited From: JsonRpcClientProtocol#gotResponse Source: client/protocol/base.js, line 224 message(method, params [, id]) Generate a stringified JSON-RPC message object Parameters: Name Type Argument Default Description method string Name of the method to use in the request params Array | JSON Params to send id boolean &lt;optional&gt; true If true it will use instances message_id for the request id, if false will generate a notification request Inherited From: JsonRpcClientProtocol#message Source: client/protocol/base.js, line 271 Example client.message(\"hello\", [\"world\"]) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"], \"id\": 1} client.message(\"hello\", [\"world\"], false) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"]} notify(method, params) Send a notification to the server. Promise will resolve if the request was sucessfully sent, and reject if there was an error sending the request. Parameters: Name Type Description method string Name of the method to use in the notification params Array | JSON Params to send Inherited From: JsonRpcClientProtocol#notify Source: client/protocol/base.js, line 297 Returns: Promise Example client.notify(\"hello\", [\"world\"]) rejectPendingCalls(error) Reject the pending call for the given ID in the error object. If the error object has a null id, then log the message to the console. Parameters: Name Type Description error string Stringified JSON-RPC error object Inherited From: JsonRpcClientProtocol#rejectPendingCalls Source: client/protocol/base.js, line 552 request() Method used to call message, notify and send Inherited From: JsonRpcClientProtocol#request Source: client/protocol/base.js, line 348 Returns: Object Example client.request().send(\"hello\", [\"world\"]) client.request().notify(\"foo\") client.request().message(\"foo\", [\"bar\"]) send(method, params) Send a request to the server Promise will resolve when a response has been received for the request. Promise will reject if the server responds with an error object, or if the response is not received within the set requestTimeout Parameters: Name Type Description method string Name of the method to use in the request params Array | JSON Params to send Inherited From: JsonRpcClientProtocol#send Source: client/protocol/base.js, line 325 Returns: Promise Example client.send(\"hello\", {\"foo\": \"bar\"}) setConnector() Set the connector attribute for the protocol instance. The connector is essentially the socket instance for the client. For the WsBrowserClientProtocol this is window.WebSocket() Overrides: WsClientProtocol#setConnector Source: client/protocol/ws-browser.js, line 15 verifyData(chunk) Verify the incoming data returned from messageBuffer Throw an error if its not a valid JSON-RPC object. Call gotNotification if the message a notification. Call gotBatch if the message is a batch request. Parameters: Name Type Description chunk string Inherited From: JsonRpcClientProtocol#verifyData Source: client/protocol/base.js, line 156 write(request [, cb]) Send a message to the server Parameters: Name Type Argument Description request string Stringified JSON-RPC message object cb function &lt;optional&gt; Callback function to be called when message has been sent Inherited From: JsonRpcClientProtocol#write Source: client/protocol/base.js, line 257 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"WsClientFactory.html":{"id":"WsClientFactory.html","title":"Class: WsClientFactory","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: WsClientFactory WsClientFactory Creates instance of WsClientFactory new WsClientFactory(options) Additional parameters ontop of those inherited from JsonRpcClientFactory Parameters: Name Type Description options object Connection options for factory class Properties Name Type Argument Default Description url string &lt;optional&gt; \"ws://127.0.0.1:8100\" Websocket URL to connect to Properties: Name Type Description url string Same as options.url Source: client/ws.js, line 9 Extends JsonRpcClientFactory Methods batch(requests) Calls batch() method on protocol instance Parameters: Name Type Description requests Array.&lt;JSON&gt; Valid JSON-RPC batch request array Inherited From: JsonRpcClientFactory#batch Overrides: JsonRpcClientFactory#batch Source: client/index.js, line 119 cleanUp(ids) Clears pending timeouts kept in timeouts for the provided request IDs. Parameters: Name Type Description ids Array.&lt;string&gt; | Array.&lt;number&gt; Array of request IDs Inherited From: JsonRpcClientFactory#cleanUp Overrides: JsonRpcClientFactory#cleanUp Source: client/index.js, line 137 connect() Calls connect() on protocol instance Inherited From: JsonRpcClientFactory#connect Overrides: JsonRpcClientFactory#connect Source: client/index.js, line 62 end() Calls end() on protocol instance Inherited From: JsonRpcClientFactory#end Overrides: JsonRpcClientFactory#end Source: client/index.js, line 71 request() Calls request() method on protocol instance Inherited From: JsonRpcClientFactory#request Overrides: JsonRpcClientFactory#request Source: client/index.js, line 110 serverDisconnected(cb) Emits a serverDisconnected event, passing the callback function Parameters: Name Type Description cb function Inherited From: JsonRpcClientFactory#serverDisconnected Overrides: JsonRpcClientFactory#serverDisconnected Source: client/index.js, line 128 subscribe(method, cb) Subscribe the function to the given event name Parameters: Name Type Description method string Method to subscribe to cb function Name of callback function to invoke on event Inherited From: JsonRpcClientFactory#subscribe Overrides: JsonRpcClientFactory#subscribe Source: client/index.js, line 82 unsubscribe(method, cb) Unsubscribe the function from the given event name Parameters: Name Type Description method string Method to unsubscribe from cb function Name of function to remove Inherited From: JsonRpcClientFactory#unsubscribe Overrides: JsonRpcClientFactory#unsubscribe Source: client/index.js, line 93 unsubscribeAll(method) Unsubscribe all functions from given event name Parameters: Name Type Description method string Method to unsubscribe all listeners from Inherited From: JsonRpcClientFactory#unsubscribeAll Overrides: JsonRpcClientFactory#unsubscribeAll Source: client/index.js, line 103 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"WsClientProtocol.html":{"id":"WsClientProtocol.html","title":"Class: WsClientProtocol","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: WsClientProtocol WsClientProtocol Creates and instance of WsClientProtocol new WsClientProtocol() Properties: Name Type Description url string The websocket URL to connect to, i.e. ws://127.0.0.1:8100 Source: client/protocol/ws.js, line 10 Requires: module:ws Extends JsonRpcClientProtocol Requires module:ws Methods batch(requests) Used to send a batch request to the server. Recommend using message to construct objects. Will use the IDs for the requests in the batch in an array as the keys for pendingCalls. How a client should associate batch responses is not in the spec, so this is the solution. Parameters: Name Type Description requests Array An array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#batch Overrides: JsonRpcClientProtocol#batch Source: client/protocol/base.js, line 370 Returns: Promise Example client.batch([client.message(\"foo\", [\"bar\"]), client.message(\"hello\", [], false)]) connect() Make the connection to the server. Calls setConnector to establish the node client connection. Calls listen if connection was successful, and will resolve the promise. Will retry connection on the connectionTimeout interval. Number of connection retries is based on remainingRetries Will reject the promise if connect or re-connect attempts fail. Inherited From: JsonRpcClientProtocol#connect Overrides: JsonRpcClientProtocol#connect Source: client/protocol/base.js, line 71 Returns: Promise end(cb) Ends connection to the server. Sets JsonRpcClientFactory.pcolInstance to undefined Parameters: Name Type Description cb function Called when connection is sucessfully closed Inherited From: JsonRpcClientProtocol#end Overrides: JsonRpcClientProtocol#end Source: client/protocol/base.js, line 108 getBatchResponse(batch) Returns the batch response. Overwrite if class needs to reformat in anyway (i.e. in HttpClientProtocol) Parameters: Name Type Description batch Array Array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#getBatchResponse Overrides: JsonRpcClientProtocol#getBatchResponse Source: client/protocol/base.js, line 429 getResponse(id) Get the outstanding request object for the given ID Parameters: Name Type Description id string | number ID of outstanding request Inherited From: JsonRpcClientProtocol#getResponse Overrides: JsonRpcClientProtocol#getResponse Source: client/protocol/base.js, line 247 gotBatch(message) Called when the received message is a batch Parameters: Name Type Description message Array.&lt;JSON&gt; A valid JSON-RPC batch message Inherited From: JsonRpcClientProtocol#gotBatch Overrides: JsonRpcClientProtocol#gotBatch Source: client/protocol/base.js, line 209 gotBatchResponse(batch) Associate the ids in the batch message to their corresponding pendingCalls. Will call _resolveOrRejectBatch when object is determined Parameters: Name Type Description batch Array Array of valid JSON-RPC message objects Inherited From: JsonRpcClientProtocol#gotBatchResponse Overrides: JsonRpcClientProtocol#gotBatchResponse Source: client/protocol/base.js, line 399 gotError(error) Calls rejectPendingCalls with error object. If the object cannot be parsed, then an unkown error code is sent with the error message Parameters: Name Type Description error string Stringified JSON-RPC error object Inherited From: JsonRpcClientProtocol#gotError Overrides: JsonRpcClientProtocol#gotError Source: client/protocol/base.js, line 527 gotNotification(message) Called when the received message is a notification. Emits an event using message.method as the name. The data passed to the event gotr is the message. Parameters: Name Type Description message JSON A valid JSON-RPC message object Inherited From: JsonRpcClientProtocol#gotNotification Overrides: JsonRpcClientProtocol#gotNotification Source: client/protocol/base.js, line 200 gotResponse(message) Called when the received message is a response object from the server Parameters: Name Type Description message JSON A valid JSON-RPC message object Inherited From: JsonRpcClientProtocol#gotResponse Overrides: JsonRpcClientProtocol#gotResponse Source: client/protocol/base.js, line 224 listen() Setup \"data\" event to listen for data coming into the client. Pushes received data into messageBuffer and calls _waitForData Inherited From: JsonRpcClientProtocol#listen Overrides: JsonRpcClientProtocol#listen Source: client/protocol/base.js, line 119 message(method, params [, id]) Generate a stringified JSON-RPC message object Parameters: Name Type Argument Default Description method string Name of the method to use in the request params Array | JSON Params to send id boolean &lt;optional&gt; true If true it will use instances message_id for the request id, if false will generate a notification request Inherited From: JsonRpcClientProtocol#message Overrides: JsonRpcClientProtocol#message Source: client/protocol/base.js, line 271 Example client.message(\"hello\", [\"world\"]) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"], \"id\": 1} client.message(\"hello\", [\"world\"], false) // returns {\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"world\"]} notify(method, params) Send a notification to the server. Promise will resolve if the request was sucessfully sent, and reject if there was an error sending the request. Parameters: Name Type Description method string Name of the method to use in the notification params Array | JSON Params to send Inherited From: JsonRpcClientProtocol#notify Overrides: JsonRpcClientProtocol#notify Source: client/protocol/base.js, line 297 Returns: Promise Example client.notify(\"hello\", [\"world\"]) rejectPendingCalls(error) Reject the pending call for the given ID in the error object. If the error object has a null id, then log the message to the console. Parameters: Name Type Description error string Stringified JSON-RPC error object Inherited From: JsonRpcClientProtocol#rejectPendingCalls Overrides: JsonRpcClientProtocol#rejectPendingCalls Source: client/protocol/base.js, line 552 request() Method used to call message, notify and send Inherited From: JsonRpcClientProtocol#request Overrides: JsonRpcClientProtocol#request Source: client/protocol/base.js, line 348 Returns: Object Example client.request().send(\"hello\", [\"world\"]) client.request().notify(\"foo\") client.request().message(\"foo\", [\"bar\"]) send(method, params) Send a request to the server Promise will resolve when a response has been received for the request. Promise will reject if the server responds with an error object, or if the response is not received within the set requestTimeout Parameters: Name Type Description method string Name of the method to use in the request params Array | JSON Params to send Inherited From: JsonRpcClientProtocol#send Overrides: JsonRpcClientProtocol#send Source: client/protocol/base.js, line 325 Returns: Promise Example client.send(\"hello\", {\"foo\": \"bar\"}) setConnector() Set the connector attribute for the protocol instance. The connector is essentially the socket instance for the client. For the WsClientProtocol this is WebSocket() Overrides: JsonRpcClientProtocol#setConnector Source: client/protocol/ws.js, line 24 verifyData(chunk) Verify the incoming data returned from messageBuffer Throw an error if its not a valid JSON-RPC object. Call gotNotification if the message a notification. Call gotBatch if the message is a batch request. Parameters: Name Type Description chunk string Inherited From: JsonRpcClientProtocol#verifyData Overrides: JsonRpcClientProtocol#verifyData Source: client/protocol/base.js, line 156 write(request [, cb]) Send a message to the server Parameters: Name Type Argument Description request string Stringified JSON-RPC message object cb function &lt;optional&gt; Callback function to be called when message has been sent Inherited From: JsonRpcClientProtocol#write Overrides: JsonRpcClientProtocol#write Source: client/protocol/base.js, line 257 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"WsServerFactory.html":{"id":"WsServerFactory.html","title":"Class: WsServerFactory","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: WsServerFactory WsServerFactory Creates and instance of WsServerFactory new WsServerFactory() Source: server/ws.js, line 10 Requires: module:ws Extends JsonRpcServerFactory Requires module:ws Methods buildProtocol() Set the pcolInstance for the server factory Inherited From: JsonRpcServerFactory#buildProtocol Overrides: JsonRpcServerFactory#buildProtocol Source: server/index.js, line 78 Example this.pcolInstance = new JsonRpcClientProtocol() clientConnected(event) Called when clientConnected event is fired. Parameters: Name Type Description event object Returns host and port or error object Inherited From: JsonRpcServerFactory#clientConnected Overrides: JsonRpcServerFactory#clientConnected Source: server/index.js, line 275 clientDisconnected(event) Called when clientDisconnected event is fired. Parameters: Name Type Description event object Returns host and port or error object Inherited From: JsonRpcServerFactory#clientDisconnected Overrides: JsonRpcServerFactory#clientDisconnected Source: server/index.js, line 284 close() Close the server connection. Stops listening. Inherited From: JsonRpcServerFactory#close Overrides: JsonRpcServerFactory#close Source: server/index.js, line 139 Returns: Type Promise listen() Start listening for client connections to server. Inherited From: JsonRpcServerFactory#listen Overrides: JsonRpcServerFactory#listen Source: server/index.js, line 51 Returns: Type Promise method(name, cb) Register a method and associated function with the server. The function will be called when a client makes a request to this method. Parameters: Name Type Description name string Name of method cb function Function to call when client makes request to method Inherited From: JsonRpcServerFactory#method Overrides: JsonRpcServerFactory#method Source: server/index.js, line 159 notify(notifications) Parameters: Name Type Description notifications Array.&lt;Array.&lt;string, (Array|object)&gt;&gt; Array of notifications Inherited From: JsonRpcServerFactory#notify Overrides: JsonRpcServerFactory#notify Source: server/index.js, line 213 Returns: Returns list of error objects if there was an error sending to any client. Returns true if the entire data was sent successfully Returns false if all or part of the data was not sent to the client. Type Array.&lt;boolean&gt; | Array.&lt;Error&gt; Example server.notify([ [\"hello\", [\"world\"]], [\"foo\", {\"bar\": \"baz\"}] ]) onNotify(method, cb) Call function when notification with event name comes in. Parameters: Name Type Description method string Method name to listen for notification cb function Name of callback function fired when method event comes in Inherited From: JsonRpcServerFactory#onNotify Overrides: JsonRpcServerFactory#onNotify Source: server/index.js, line 174 Example function world(){ return 'foo' } server.onNotify(\"hello\", world) removeAllOnNotify(method) Remove all functions listening for event name. Parameters: Name Type Description method string Method name to remove events for Inherited From: JsonRpcServerFactory#removeAllOnNotify Overrides: JsonRpcServerFactory#removeAllOnNotify Source: server/index.js, line 198 removeOnNotify(method, cb) Remove function name from listening for notifications. Parameters: Name Type Description method string Method name to remove cb function Name of the callback function to remove Inherited From: JsonRpcServerFactory#removeOnNotify Overrides: JsonRpcServerFactory#removeOnNotify Source: server/index.js, line 189 Example function world(){ return 'foo' } server.removeOnNotify(\"hello\", world) sendNotification(client, response) Send notification to client Parameters: Name Type Description client class Client instance response string Stringified JSON-RPC message to sent to client Source: server/ws.js, line 85 Throws: Will throw an error if client is not defined &lt;abstract&gt; setServer() Set the server property for the server factory Inherited From: JsonRpcServerFactory#setServer Overrides: JsonRpcServerFactory#setServer Source: server/index.js, line 88 Example this.server = new net.Server() setSever() Source: server/ws.js, line 37 setupListeners() Setup the error and close events for the factory and server. Sets listening to false if any errors returned or if server stops listening. Calls the JsonRpcServerFactory and JsonRpcServerFactory methods Inherited From: JsonRpcServerFactory#setupListeners Overrides: JsonRpcServerFactory#setupListeners Source: server/index.js, line 100 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "},"WsServerProtocol.html":{"id":"WsServerProtocol.html","title":"Class: WsServerProtocol","body":" Jaysonic Namespaces JaysonicUtilsUtils.constantsUtils.format Classes HttpClientFactoryHttpClientProtocolHttpServerFactoryHttpServerProtocolJsonRpcClientFactoryJsonRpcClientProtocolJsonRpcServerFactoryJsonRpcServerProtocolMessageBufferTcpClientFactoryTcpClientProtocolTcpServerFactoryTcpServerProtocolWsBrowserClientFactoryWsBrowserClientProtocolWsClientFactoryWsClientProtocolWsServerFactoryWsServerProtocol Class: WsServerProtocol WsServerProtocol Creates instance of WsServerProtocol new WsServerProtocol() Properties: Name Type Description event string HTTP response object client.write object Overrides client.write to use client.send for Websocket Source: server/protocol/ws.js, line 7 Extends JsonRpcServerProtocol Methods clientConnected() Registers the event listener when client connects. Pushes received data into messageBuffer and calls _waitForData. Registers end event to emit a clientDisconnected event on the factory Inherited From: JsonRpcServerProtocol#clientConnected Overrides: JsonRpcServerProtocol#clientConnected Source: server/protocol/base.js, line 38 getResult(message) Get the result for the request. Calls the function associated with the method and returns the result. Parameters: Name Type Description message JSON Valid JSON-RPC message object Inherited From: JsonRpcServerProtocol#getResult Overrides: JsonRpcServerProtocol#getResult Source: server/protocol/base.js, line 249 Returns: Type Promise gotBatchRequest(requests) Attempts to get the result for all requests in the batch. Will send result to client if successful and error otherwise. Parameters: Name Type Description requests Array.&lt;JSON&gt; Valid JSON-RPC batch request Inherited From: JsonRpcServerProtocol#gotBatchRequest Overrides: JsonRpcServerProtocol#gotBatchRequest Source: server/protocol/base.js, line 225 Returns: Type Array.&lt;Promise&gt; gotError(error) Writes error to the client. Will send a JSON-RPC error object if the passed error cannot be parsed. Parameters: Name Type Description error string Stringified error object Inherited From: JsonRpcServerProtocol#gotError Overrides: JsonRpcServerProtocol#gotError Source: server/protocol/base.js, line 322 gotNotification(message) Calls emit on factory with the event name being message.method and the date being message. Parameters: Name Type Description message string Stringified JSON-RPC message object Inherited From: JsonRpcServerProtocol#gotNotification Overrides: JsonRpcServerProtocol#gotNotification Source: server/protocol/base.js, line 196 gotRequest(message) Attempts to get the result for the request object. Will send result to client if successful and will send an error otherwise. Parameters: Name Type Description message JSON JSON-RPC message object Inherited From: JsonRpcServerProtocol#gotRequest Overrides: JsonRpcServerProtocol#gotRequest Source: server/protocol/base.js, line 208 Returns: Type Promise validateMessage(message) Validates if there are any issues with the incoming request Parameters: Name Type Description message JSON Valid JSON-RPC request object Inherited From: JsonRpcServerProtocol#validateMessage Overrides: JsonRpcServerProtocol#validateMessage Source: server/protocol/base.js, line 147 Throws: Will throw an error for any of the below reasons Reason Type message is not an object Invalid Request the server does not have the required method Method Not Found the params are not an array or object Invalid Params the \"jsonrpc\" property was passed for a v1 server Invalid Request validateRequest(chunk) Validate the incoming data returned from messageBuffer Parameters: Name Type Description chunk string Inherited From: JsonRpcServerProtocol#validateRequest Overrides: JsonRpcServerProtocol#validateRequest Source: server/protocol/base.js, line 84 Throws: Will throw an error with a JSON-RPC error object if chunk cannot be parsed Returns: Type JSON writeToClient(message) Send message to the client Parameters: Name Type Description message string Stringified JSON-RPC message object Inherited From: JsonRpcServerProtocol#writeToClient Overrides: JsonRpcServerProtocol#writeToClient Source: server/protocol/base.js, line 186 × Search results Close Documentation generated by JSDoc 3.6.6 on 2020-10-12T21:58:28-04:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
